
---


- 채원님 리포지토리
	- 운영체제
		- 1주차
		- 2주차
		- 3주차
		- 4주차
	- 네트워크
		- 1주차
- 연호님 리포지토리 
	- 운영체제
		- 1주차
		- 2주차
		- 3주차
		- 4주차
	- 네트워크
		- 1주차

---
- 진행 상태
	- 1주차 2023 / 12 / 10 
		 - 운영체제가 무엇인지 설명하시오.  
			 - "운영체제는 부팅 프로그램에 의해 컴퓨터에 처음 로드된 후 다른 모든 응용 프로그램을 관리하는 프로그램이다." 응용 프로그램은 정의된 API(응용 프로그램 인터페이스)를 통해 서비스를 요청함으로써 운영체제를 활용한다. 또한 사용자는 명령줄 인터페이스(CLI)나 그래픽UI(GUI)와 같은 사용자 인터페이스를 통해 운영체제와 직접 상호 작용할 수 있다. * 운영체제를 사용하는 이유는? : 운영체제는 컴퓨터 소프트웨어 및 소프트웨어 개발에 강력한 이점을 제공한다. 운영체제가 없으면 모든 어플리케이션에는 자체 UI는 물론 디스크 저장소, 네트워크 인터페이스 등과 같은 기본 컴퓨터의 모든 하위 수준 기능을 처리하는데 필요한 포괄적인 코드를 포함되어야 한다. 사용 가능한 기본 하드웨어의 방대한 배열을 고려할 때 이는 모든 어플리케이션의 크기를 엄청나게 부풀리고 소프트웨어 개발을 비현실적으로 만든다. 2. 프로세스와 스레드의 차이에 대해서 설명하시오. * 프로세스는 운영체제로부터 자원을 할당받은 "작업의 단위"이고, 스레드는 프로세스가 할당받은 자원을 이용하는 "실행의 단위"이다. * 프로세스란? : 우선 프로세스의 설명에 앞서 우리에게 친숙한 프로그램에 대해 이야기를 조금 할 것이다. 우리가 친숙하게 사용하는 프로그램들은 윈도우.exe 맥 .dmg 파일과 같은 컴퓨터에서 실행할 수 있는 파일들을 통칭한다. 여기서 파일을 아직 실행하지 않은 상태를 "정적 프로그램",줄여서 "프로그램"이라고 부른다. 어떠한 프로그램을 개발하기 위해선 자바나 C언어 같은 언어를 이용해서 코드를 작성하고 완성한다. 즉 프로그램은 쉽게 말해서 코드의 덩어리 인것이다. 프로그램이 그냥 코드의 덩어리이면, 프로세스는 프로그램을 실행 시켜서 정적인 프로그램을 동적인 프로그램으로 변하여 프로그램이 돌아가는 상태를 의미한다. 즉, "작업 중인 프로그램이 곧 프로세스"를 의미한다. (작업관리자에 실행중인 프로그램들을 프로세스라고 명명되어있던 것을 기억해보자) 모든 프로그램은 운영체제가 실행되기 위한 메모리 공간을 할당해 줘야 실행할 수 있다. 그래서 프로그램을 실행하는 순간 파일은 컴퓨터 메모리에 올라가게 되고, 운영체제로부터 시스템 자원(CPU)를 할당 받아 프로그램 코드를 실행시켜서 우리가 서비스를 이용할 수 있게 되는 것이다. * 프로세서는 실행될 때 운영체제로부터 프로세서, 필요한 주소 공간, 메모리 등 자원을 할당받는다. 스레드란 한 프로세스 내에서 동작되는 여러 실행의 흐름으로 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다. 즉, 프로세스와 스레드에 대한 질문은 결국에는 운영체제가 시스템의 자원을 어떤 단위로 할당하고 프로세스와 스레드는 이 자원을 어떻게 사용하느냐를 알고 있냐에 대한 질문이다. * 그렇가면 왜, 여러 프로세스(멀티 프로세스)로 할 수 있는 작업들을 굳이 하나의 프로세스에서 스레드로 나눠가면서 할까? : 그 이유는 간단하다. 운영체제는 시스템 자원을 효율적으로 사용하기 위해 스레드를 사용하는 것이다. 자세히 이야기하자면 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다. 뿐만 아니라 프로세스간의 통신보다 스레드 간의 통신의 비용이 적으므로 작업들간의 통신의 부담이 줄어든다. 이처럼 스레드를 활용하면 자원의 효율성이 증가하기도 하지만 스레드 간의 자원 공유는 전역 변수를 이용하므로 동기화 문제에 신경을 써야 한다. 때문에 멀티 스레드 프로그레밍은 프로그래머의 주의가 요구된다. 다시한번 강조하자면, 위의 질문의 핵심은 "운영체제에서 작업을 실행할 때, 자원을 할당하는 단위를 알고있느냐와" "프로그램을 멀티 스레드를 구현할 때 장, 단점을 알고있느냐"에 대한 질문이다. 3. 시스템 호출에 대해서 설명하시오. - 시스템 콜 (시스템 호출) | System Call : 시스템 콜은 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스이다. 보통 C나 C++과 같은 고급 언어로 작성된 프로그램들은 직접 시스템을 호출할 수 없기 때문에 고급 API를 통해 시스템 호출에 접근하게 하는 방법이다. - 시스템 콜이 필요한 이유 : 우리가 일반적으로 사용하는 프로그램은 "응용 프로그램"이다. 유저 레벨의 프로그램은 유저 레벨의 함수들 만으로는 많은 기능을 구현하기 힘들기 떄문에, 커널(kernel)의 도움을 반드시 받아야 한다. 이러한 작업은 응용프로그램으로 대표되는 유저 프로세스(User Process)에서 유저모드를 수행할 수 없다. "반드시" kernel에 관련된 것은 커널 모드로 전환한 후에야, 해당 작업을 수행할 권한이 생긴다. 커널 모드를 통한 이러한 작업을 반드시 "시스템 콜"을 통해 수행하도록 설계되어 있다. 그렇다면 왜 권한이 필요한 것인가? 그 이유는 해커가 피해를 입히기 위해 악의적으로 시스템 콜을 사용하는 경우나, 초보 사용자가 하드웨어 명령어를 잘 몰라서 아무렇게 함수를 호출했을 경우에 시스템 전체를 망가뜨릴 수 있기 때문이다. 따라서 아러한 명령어들은 특별하게 커널 모드에서만 실행할 수 있도록 설계되었고, 만약 유저 모드에서 시스템 콜을 호출할 경우에는 운영체제에서 불법적인 접근이라 여기고 trap을 발생시킨다. 4. 커널의 개념을 설명하시오. 커널은 컴퓨터 운영체제의 핵심에 있는 컴퓨터 프로그램이며 일반적으로 시스템의 모든 것을 완벽하게 제어한다. 커널은 또한 서로 다른 프로세스 간의 충돌을 방지하고 완화하는 역할을 담당한다. * 하드웨어와 소프트웨어 구성 요소 간의 상호 작용을 용이하게 하는 운영 체제 코드의 일부이다. 전체 커널은 장치 드라이버를 통해 모든 하드웨어 리소스(예 : I/O, 메모리, 암호화)를 제어하고 이러한 리소스와 관련된 프로세스 간의 충돌을 조정하며 CPU 및 캐시 사용량, 파일 시스템 및 네트워크 소켓과 같은 리소스의 활용을 최적화한다. 대부분의 시스템에서 커널은 시작 시 로드되는 첫번쨰 프로그램 중 하나이다. 나머지 시작은 물론 소프트웨어의 메모리, 주변 장치 및 입출력(I/O) 요청을 처리 하여 이를 중앙 처리 장치에 대한 데이터 처리 명령으로 변환한다. * 커널의 중요한 코드는 일반적으로 별도의 메모리 영역에 로드되어 응용 프로그램 소프트웨어 나 운영체제의 덜 중요한 부분에 의한 엑세스로부터 보호된다. 커널은 보호된 커널 공간에서 프로세스 실행, 하드 디스크와 같은 하드웨어 장치 관리, 인터럽트 처리 등의 작업을 수행한다. 이에 비해 브라우저, 워드 프로세서, 오디오나 비디오 플레이어 등의 응용 프로그램은 별도의 메모리 영역인 사용자 공간을 사용한다. 이러한 분리는 사용자 데이터와 커널 데이터가 서로 간섭하여 불안정성과 속도를 저하시키는 것을 방지할 뿐만 아니라 오작동하는 응용 프로그램이 다른 응용 프로그램에 영향을 미치거나 전체 운영 체제를 충돌시키는 것을 방지한다. 커널이 어플리케이션 주소 공간에 포함된 시스템에서도 인증되지 않은, 어플리케이션이 커널을 수정하는 것을 방지하기 위해 메모리 보호가 사용된다. * 커널은 인터페이스가 낮은 수준의 추상화 계층이다. 프로세스가 커널로부터 서비스를 요청할 때 일반적으로 래퍼 함수를 통해 시스템 호출을 호출 해야한다. * 컴퓨터 시스템의 이 핵심 구성 요소는 프로그램 실행을 담당한다. 커널은 실행 중인 많은 프로그램 중 프로세서에 할당해야 하는 프로그램을 언제든지 결정하는 책임을 진다.
	- 2주차 
		- 0.인트로 제가 공부한 커널모드의 구체적인 사례는 두가지를 조사해 보았는데요 첫번째는 지난 시간에 말씀드렸던 관리자 권한의 실행이고 두번째는 디바이스 드라이버입니다. 우선 이 두가지 사례를 설명드리기 앞서서 간단하게 커널이 무엇인지 다시 짚어보도록 하겠습니다. 1.커널이란? 운영체제의 가장 중요한 프로그램으로서 시스템의 모든 것을 통제할 수 있는 핵심 프로그램 중 하나입니다. 2.커널의 역할 커널의 역할은 크게 3가지로 나뉠 수 있는데, 첫번째로 보안, 두번째로 자원관리, 세번째로 추상화입니다. 여기서 커널은 자원관리를 효율적으로 할 수 있도록 CPU 스케줄링, 메모리 관리, 입출력관리, 파일시스템 관리 등의 업무를 수행합니다. 이 후 말씀 드릴 커널모드의 사례에 대한 설명 중 커널의 역할 세가지가 모두 포함되며 디바이스 드라이버의 경우는 입출력관리를 목적으로 하기 때문에 간단하게 짚고 넘어가보았습니다. 3.관리자 권한의 실행 우선 먼저 관리자 권한의 실행에 대해 설명드리겠습니다. 우리가 커널을 공부할 때 유저모드와 커널모드가 존재하는 걸 배웠었고 대부분의 어플리케이션과 응용프로그램은 유저모드로 실행된다는걸 배웠습니다. 관리자 권한의 실행은 커널모드의 일종으로 시스템콜을 통해 유저모드를 커널모드로 일시적으로 전환하는 역할을 합니다. 이러한 관리자 실행의 커널모드는 기존 유저모드는 접근할 수 없는 레지스트리로 접근이 가능해집니다. 레지스트리란 쉽게 말해 운영체제의 데이터베이스라고 생각하면 됩니다. 이 레지스트리를 접근할 수있음으로써 어플리케이션이나 응용프로그램은 더 많은 일을 할 수 있도록 해줍니다. 그렇다면 굳이 일반 실행과 관리자 권한의 실행으로 분류된 구체적인 목적은 무엇인가? 첫번째로는 사용자의 실수로 인해 치명적인 오류 방지이다. 레지스트리는 운영체제의 중요한 프로그램이기에 유저가 직접적으로 데이터나 정보를 함부로 변경하거나 모든 어플리케이션과 응용프로그램에 접근을 허용하면 컴퓨터를 사용하며 예상하기 힘든 문제를 발생할 위험이 크다. 이러한 잠재적 위험들을 막기 위함이다. 여기서 의문인건 그렇다면 우리가 프로그램을 실행할 때 관리자 권한 실행하는 것 자체가 위험한게 아닌가 할 수 있지만 프로그램을 개발한 개발자들은 대부분 프로그램을 설계할 때 사용자가 관리자 권한 실행을 할 때 가능한 안전한 범위에서 접근할 수 있도록 설계를 하기 때문에 상대적으로 안전하다. 다만 관리자 권한의 실행은 각 설계자들이 본인의 프로그램에 맞게 설계한 것이기에 여러가지 프로그램을 동시에 사용하면서 관리자 권한의 실행을 할 때 예상하지 못한 오류를 일으킬 가능성이 존재한다. 즉 가급적이면 관리자권한의 실행은 최소한으로 하는게 안전하다. 그리고 두번째로는 해커로부터 데이터를 보호하기 위함입니다. 우리가 항상 사용하는 관리자 권한의 실행은 마우스로 우클릭하여 관리자 권한 실행을 클릭하고 나타나는 창으로 예를 클릭하여 실행되는 과정인데 이러한 다소 번거로운 과정을 거치는 이유는 이런 뜻이다. "너가 정말 이 컴퓨터 앞에 앉아 있는 관리자가 맞느냐?" "혹시라도 악의적인 목적을 가진 프로그램이 일부러 관리자의 권한을 얻어서 컴퓨터에 장난질하려는 것이 아니냐?" "너가 진짜 이 컴퓨터 앞에 앉아서 사용하고 있는 관리자라면" "여기 화면에 보이는 예 버튼을 눌러라" 즉 우리가 현실의 예시로 들 수 있는 공항의 입국심사, 스마트폰 패턴잠금, 우리가 살고있는 집에 도둑을 방지한 열쇠 등 같은 귀찮지만 반드시 필요한 보안절차라고 생각하면 된다. 4. 디바이스 드라이버 두번째 커널모드의 사례로 디바이스 드라이버에 대해 설명하자면 디이스 드라이버는 관리자 권한 실행과 같이 일종의 커널이며 특정한 하드웨어나 장치를 제0어하기 위한 커널의 일종으로 동작하는 프로그램이다. 쉽게 이야기하자면 우리가 사용하는 모든 입출력장치인 마우스, 키보드, 이어셋, 복합기 등과 같은 하드웨어들과 컴퓨터의 운영체제가 서로 알아들을 수 있도록 통역해주는 역할을 하는 커널이라 생각하면 된다. 이러한 입출력 장치를 사용하면서 프로세스를 실행하는 동안 우리가 인지하고 있지 못하지만 유저모드와 커널모드를 수없이 왔다갔다하며 실행된다. 프로세스는 일반적으로 유저모드로 실행되다가 특별한 요청이 필요할 때 system call을 통해 커널모드로 요청을 한다. 그리고, system call의 요청을 받은 커널이 그 요청에 대한 일을 처리하고 반환값을 system call이 리턴한다. 이해하기 쉽게 예시를 들어보겠다. 우리가 마우스로 카카오톡 아이콘을 클릭해보자 나는 하드웨어의 입출력장치로 운영체제의 프로그램을 동작하게 하는것이다. 이는 앞서 설명한 디바이스 드라이버라는 커널로 하드웨어의 입출력장치와 컴퓨터의 운영체제와 서로 연결시켜서 알아들을 수있도록 통역해주는 역할이다. 마우스 클릭이나 키보드의 입력, 모니터의 화면 출력 등의 입출력관리는 단순하게 생각할 수 있지만 엄연히 유저모드로는 접근할 수 없는 영역이다. 그러므로 프로세스를 실행하며 사용하는 중 발생하는 대부분의 모든 행동은 하드웨어로 동작하기에 처음에 설명한 커널의 역할 수행 중 하나인 입출력관리는 엄연히 커널의 권한이기에 프로세스를 사용하는 수많은 상황에서 유저모드와 커널모드를 수없이 왔다갔다하는거다. 그리고 그 왔다갔다할 수 있도록 중계해주는 역할이 바로 디바이스 드라이버라는 커널모드이다.
		-  멀티 스레드의 이점과 한계 1장 이점 1.응답성 : 프로그램의 일부분(스레드)가 중단되거나 긴 작업을 수행해도 프로그램의 수행이 계속되어 사용자의 응답성이 증가한다. 이는 단일 스레드가 순차 실행이고 멀티 스레드는 병렬 실행이기에 가능한 것이다. * 예시 1 : 웹브라우저를 이용할 때 특정한 설치 파일을 다운로드하는 동시에 웹서핑이나, 블로그 이용, 날씨확인 등 다양한 서비스를 동시에 이용하는 것과 같은 원리이다. * 예시 2 : 우리가 브라우저의 카카오톡이나 구글 설치 등 설치 파일을 같이 할때 동시에 다운로드가 진행 될 것이다. 이것이 멀티 스레드이다. 2.경제성 : 프로세스 내의 자원들과 메모리를 공유하기 때문에 메모리 공간과 시스템 자원과 소비가 절약된다. 스레드 간의 통신이 필요한 경우에도 쉽게 데이터를 주고 받을 수 있고 프로세스의 컨텍스트 스위칭과 달리 스레드의 컨텍스트 스위칭은 캐시 메모리를 비울 필요가 없기 때문에 훨씬 가볍고 빠르다. 다만 스레드가 다른 CPU 코어에서 실행될 때는 해당 코어의 캐시 메모리에 스레드 컨텍스트 정보가 로드되어야 하므로 초기화 될 수 있다. 2장 한계 1.임계영역의 동기화 문제 : 멀티 스레드의 자원 공유는 장점이 될 수도 있지만 단점이 될 수도 있다. 하나의 스레드가 자원을 공유하고 있을 때, 다른 스레드에서 이 자원을 사용한다면, 원래 원하던 값이 아닌 변경된 값을 읽어 오는 경우가 생길 수 있다. 예를들어 A라는 작업과 B라는 작업이 있을 때 A는 0에서 1을 더하고 B는 0에서 1을 빼는 작업이 있다면 A가 먼저 작업할 경우 B가 작업해야할 때 예상결과값이 바뀌게 된다. 0이 되어야하는데 1이 되거나 -1이 되는 문제가 발생하는 것이다. 이러한 것을 임계영역이라 부른다. 이러한 문제를 해결하기 위해 "동기화 작업"이 필요하다. 동기화작업은 작업 처리 순서를 조정하고 공유 자원에 대한 권한을 컨트롤하는 것 이러한 작업으로 인해 스레드가 작업을 수행할 때 공유자원을 사용할 권한을 기다리게 되면서 병목현상이 발생해 성능을 저하시킬 수 있기에 "과도한 락"으로 인한 병목현상을 줄여줘야한다. 스레드 컨텍스트 스위칭이 발생해 다른 스레드의 heap의 영역의 공유 데이터에 접근할때, 이전 스레드가 이미 공유 자원을 사용하고 있는 경우 동기화 문제가 발생할 수 있다. 예를들어 두개의 스레드가 하나의 변수를 수정하려고 할 때, 스레드의 컨텍스트 스위칭이 발생하면 변수의 값을 잘못된 값으로 업데이트 할 수 있는 것이다. 이것이 스레드 간의 경쟁조건이라고 한다. 따라서 이들을 해결하기 위해선 각 상황에 적절한 자원 공유에 대한 동기화 메커니즘이 필요하다. 해결방법은 뮤텍스와 세마포어가 있다. 2.병목현상 : 멀티 스레딩에서 여러 스레드가 자원을 동시에 접근할 때, 성능이 저하되는 헌상을 말함, 병목 현상은 공유 자원에 대한 경쟁이나 동기화 문제로 발생한다. 3.컨텍스트 스위칭 오버헤드 : 멀티 스레드의 컨텍스트 스위칭이 프로세스의 컨텍스트 스위칭보다 오버헤드가 훨씬 적다는 장점이 있었을 것이다. 하지만, 상대적으로 프로세스에 비해 적다는 것이지 멀티 스레드도 오버헤드 자체 비용을 결코 무시할 수 없다. 즉, 싱글 스레드는 스레드가 한개 이니 컨텍스트 스위칭 오버헤드가 발생하지 않지만, 멀티 스레드 모델은 스레드가 여러개이니 컨텍스트 스위칭 오버헤드가 발생하게되고, 스레드가 많으면 많을수록 스위칭 횟수가 많아지고 덩달아 오버헤드도 많아져 성능저하가 될 수 있다. 4.자연 스레드의 리소스 낭비 : 많은 양의 작업을 여러개의 스레드로 빠르게 처리한다는 멀티 스레드의 취지는 좋지만, 회사의 서비스 이용률이 24시간 항상 바쁜 상태는 아닐 것이다. 즉, 멀티 스레드 어플리케이션 에서 이용률이 한산하여 스레드를 한 두개 밖에 이용하지 않을 때, 나머지 잔여 스레드들이 CPU, 메모리, 네트워크 등의 자원이 불필요하게 점유해서 성능 저하나 오류의 원인이 될 수 있다. 놀고 있는 스레드가 많을 수록 불필요하게 메모리를 차지하고 있는 셈이니 당연히 시스템 자원의 낭비가 발생한다. 그런데 놀고 있음에도 CPU는 다른 스레드에게 CPU 시간을 양도하도록 설계되어 있기에 노는 스레드와 다른 스레드 간에 컨텍스트 스위칭을 하여 CPU의 효율성을 떨어뜨린다. 즉, 스레드가 작업을 수행하지 않더라도 존재 자체만으로 여전히 리소스를 소비하고 오버헤드를 생성하기 때문에 잔여 스레드의 문제는 결코 가볍지 않다. 이러한 문제를 해결하기 위해 노는 스레드 갯수를 최소화하고, 스레드 풀(Thread Pool)과 같은 메커니즘을 사용하여 스레드의 갯수를 관리하여 리소스 낭비를 최소화 하는 것이 중요하다. 5.어플리케이션의 성격에 따른 제약 : "스레드를 많이 쓰면 쓸수록 동시에 더 많은 작업들을 실행할 수 있다."라는 말에 우리도 모르게 암묵적으로 해당 어플리케이션을 더 작은 작업으로 잘게 쪼개서 동시에 실행이 가능한 어플리케이션이라는 전제를 깔고 생각한다. 즉, 어플리케이션의 목적과 주제에 따라 아키텍쳐가 달라질 수 있다는 얘기이다. 예를들어 만약 개발하는 어플리케이션의 동작이 순차적으로 실행되어야만 하는 특징을 가지거나 잘게 쪼개서 실행하기에 매우 어려운 성격의 어플리케이션이라면 오히려 멀티 스레드 구성은 별 이점이 없다는 것이다. 이에 대한 대표적인 예시가 CPU 바운드 어플리케이션과 I/O 바운드 어플리케이션이다. 6.프로그래밍 난이도 : 싱글 스레드는 단 하나의 스레드가 모든 작업을 처리하기 떄문에, 프로그램 구조가 단순하고 개발이 더 쉬우며, CPU, 메모리를 더 적게 사용한다. 반면 멀티 스레드는 스레드 간의 동기화 처리, 잘못된 스레드 관리로 인해 메모리 누수, 데드락 등의 문제에 대해 관리가 필요하기 때문에 개발이 굉장히 복잡해진다. 멀티 스레드는 분명히 싱글 스레드보다 성능이 뛰어나지만 무턱되고 멀티 스레드로 개발을 진행하다가 온갖 동시성 문제에 직면하여, 어플리케이션의 안정성과 유지보수성을 저해하는 것으로 두마리의 토끼를 잡으려다가 한마리도 못잡는 격이 될 수 있으니 높은 수준의 역량과 경험이 요구되며, 모델 선택에 있어, 신중하게 고려하고, 프로그램의 특성과 목적에 따라 멀티 스레딩 전략을 선택하고, 성능 최적화와 동시성 관련 이슈들에 대한 철저한 이해와 학습이 필요하다.
	- 3주차 
		- - CPU 점유율 100%의 원인과 해결방법 - 100%가 되어도 유지가 되는 이유 - 100%에는 유지가 되는 이유는? - 원인과 해결법 * 시각적인 현상 및 버그 실제 CPU 점유율에 영향을 끼치지않는 시각적인 오류 * 윈도우 색인 서비스 문제 링크 참고 * 랜카드 드라이버 네트워크 문제 링크 참고 * 에드웨어, 멀웨어 등 악성코드로 인한 점유율 증가 문제 멀웨어 검사 * 응용프로그램 개발자의 설계미스 특정 지침 온라인 검색 솔루션 프로그램 사용 * 컴퓨터 성능 문제 부품 교체 및 드라이브 업데이트 - 해결법 * PC 재부팅 * 종료 또는 다시 시작 프로세스 * 시작 프로그램 차 * 드라이브 업데이트 * 멀웨어 검사 * 솔루션 프로그램 사용 - 특정한 응용프로그램의 CPU가 비정상적으로 높아지는 이유
- 답변 요령 
	1) 시작은 한마디로 간결하게 시작한다. 
	2) 후술로 상세하게 풀어 설명한다. 
	3) 꼬리 질문 대비할 수있는 내용을 미리 준비한다. 
- 출처
	- 운영체제란 무엇인가 : [https://www.techtarget.com/whatis/definition/operating-system-OS](https://www.techtarget.com/whatis/definition/operating-system-OS)
	- 프로세스와 스레드의 차이에 대해 설명 : [https://brunch.co.kr/@kd4/3](https://brunch.co.kr/@kd4/3)
	- 시스템 호출에 대해서 설명 : [https://fjvbn2003.tistory.com/306](https://fjvbn2003.tistory.com/306)
	- 커널의 개념을 설명 : [](https://en.wikipedia.org/wiki/Kernel_(operating_system))[https://en.wikipedia.org/wiki/Kernel_(operating_system)](https://en.wikipedia.org/wiki/Kernel_(operating_system))

---