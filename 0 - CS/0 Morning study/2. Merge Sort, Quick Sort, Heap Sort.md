---
created:
---
---
# **README**

#### 병합 정렬 (Merge Sort)

- **동작**: 배열을 분할(Divide) → 정렬(Conquer) → 병합(Merge)하는 과정을 반복.
- **특징**:
    - 배열을 계속 반으로 나눠 크기가 1이 될 때까지 재귀적으로 분할.
    - 분할된 배열을 병합하며 정렬.
    - 안정적인 정렬로 **시간 복잡도**는 `O(n log n)`이며, 별도 저장 공간이 필요.
- **장점**: 안정적인 정렬.
- **단점**: 추가 메모리 사용.

---

#### 퀵 정렬 (Quick Sort)

- **동작**: 기준점(Pivot)을 정해 분할 → 재귀적으로 정렬 반복.
- **특징**:
    - 배열을 피벗 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할.
    - 피벗 선택에 따라 최악의 경우 시간 복잡도 `O(n²)` 가능.
    - 일반적으로 매우 빠른 정렬로 `O(n log n)`의 평균 시간 복잡도.
- **장점**: 메모리 사용이 적고 빠른 수행 속도.
- **단점**: 비안정적이며 최악의 경우 성능 저하.

---

#### 힙 정렬 (Heap Sort)

- **동작**: 배열을 힙(Heap)으로 구성한 뒤 최대값(루트)을 꺼내 정렬.
- **특징**:
    - **힙 구성 단계**: 배열을 완전 이진 트리로 변환하고 최대 힙으로 재구성.
    - **정렬 단계**: 루트와 배열 끝을 교환하며 반복적으로 힙 재구성.
    - 시간 복잡도는 `O(n log n)`, 공간 복잡도는 `O(1)`.
- **장점**: 메모리 효율적, 제자리 정렬 가능.
- **단점**: 비안정적이며 구현이 복잡.

---

### 정렬 알고리즘 비교

|정렬 알고리즘|평균 시간 복잡도|최악 시간 복잡도|공간 복잡도|안정성|
|---|---|---|---|---|
|병합 정렬|O(n log n)|O(n log n)|O(n)|안정적|
|퀵 정렬|O(n log n)|O(n²)|O(log n)|비안정적|
|힙 정렬|O(n log n)|O(n log n)|O(1)|비안정적|
