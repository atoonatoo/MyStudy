---
created:
---
---
- [[CS LoadMap]]
---

# Data Structure

##### **1. 자료구조를 사용하는 이유**

1. **효율적인 데이터 처리와 문제 해결을 하기 위해서**
   
2. **자료 구조는 데이터를 어떻게 저장하고 관리할지를 정의**
   
3. **자료 구조는 특정 작업을 효율적으로 처리 할 수 있도록 설계**

	1. 데이터 접근과 처리의 효율성
		- 배열, 리스트 - 빠른 조회
		- 스택, 큐 - 순서대로 처리
		- 해시 테이블 - 빠른 키-값 검색 제공
		  
	2. 메모리 사용 최적화
		- 연결 리스트 - 동적 메모리 할당
		- 배열 - 빠른 메모리 접근
		- 해시 테이블 - 빠른 키-값 검색 제공
		- 힙 - 우선순위 큐 처리
		  
	3. 알고리즘 최적화
		- 이진 탐색 트리 - 효율적인 검색, 삽입, 삭제
		- 그래프는 최단 경로 탐색
		- 힙 - 우선순위 큐 구현
		  
	4. 작업 순서와 데이터 우선순위 처리
		- 스택 - 후입선출
		- 큐 - 선입선출
		- 힙 - 우선순위 큐 처리
		  
    5. 문제 해결, 추상화
	    - 문제를 단순화
	    - 알고리즘을 이해하기 쉽게 만든다.
	      
	6. 성능 최적화
		- 배열 - 빠른 조회
		- 연결 리스트 - 삽입, 삭제 빈번할 경우
		- 해시 테이블은 빠른 검색, 삽입, 삭제
		- 힙은 우선순위 큐
	    
	7. 다양한 문제 해결
		- 그래프 - 소셜 네트워크, 도로 네트워크 분석
		- 트리 - 계층적 데이터 처리
		  
    - 결론
	    - 효율적인 데이터 저장
	    - 문제 해결 최적화
	    - 성능 개선
	    - 적합한 자료 구조 선택은 알고리즘 효율성, 메모리 사용, 실행 시간을 최적화할 수 있다.

---
### **2. 자료 구조 종류**

- [[Linked List]]
- [[Array]]
- [[Stack]]
- [[Queue]]
- [[Hash Table]]
- [[Heap]]
- [[Binary Search Tree, BST]]
- [[Sorting]]

---
##### **스택 (Stack)**  

- **데이터를 쌓아올리는 구조 방식**
- **FILO (First In Last Out, 선입후출)** : 처음에 오는 데이터가 제일 마지막에 나감
- **LIFO(Last In First Out, 후입선출)** : 제일 마지막에 들어온 데이터가 제일 먼저 나감
	- 같은 말이지만 LIFO를 자주 표현에 사용
- 데이터를 처리하는 방식으로 네트워크나 시스템에 많이 사용
- 대표적인 예 
	- 실행 취소 : Ctrl + Z
	- 웹브라우저 뒤로가기
	- 계산기
	- 햄버거 놀이
	
- 대표적인 스택 구현 방법
	
	- 1차원 배열 (정적)
		- 장점 - 구현은 상대적으로 쉽다.
		- 단점 - 인풋 사이즈를 미리 알아야한다.
	- 리스트 (동적)
		- 장점 - 구현은 상대적으로 어렵다.
		- 단점 - 재한된 사이즈로부터 자유롭다.
	
- 스택의 주요 기능
	  
	- Push
		- 스택에 데이터를 추가하는 함수
	- Pop
		- 스택에 최상위 데이터를 빼내어서 가져오는 기능
		
	- Peak(Top)
		- 제일 최근에 들어간 데이터, 최상위 데이터
		  
	- 택시기사
		- 요금을 지불할 때 동전을 넣고(push) 빼고(pop) 한다.

---

##### **큐 (Queue)**  

- **제일 먼저 들어온 값이 제일 먼저 나가는 구조**
- **FIFO (First In Fisrt Out, 선입선출)**

- 대표적안 사용사례
	- 프로세스 스케줄링
	- 대부분의 입출력 (ex 파일 입출력 등)
	- 프린트 대기열
	- 네트워크 패킷 처리
	- 게임 대기열 (ex 로아, 오버워치)
	
- 구현하는 방법
	- Array (정적) 
		- (ex Fixed Array)
		- 구현이 쉽다.
		- 고정된 Queue 크기
	- Array (동적)
		- (ex Linked List)
		- 자유로운 Queue 크기
		- 구현이 약간 더 어렵다.
	  
- 대표적인 함수
	- Enqueue - 큐에 값을 집어넣는 함수
	- Dequeue - 큐에서 값을 뺴내는 함수
	- size - 큐의 크기를 확인하는 함수
	- empty - 큐가 비어있는지 확인하는 함수
	  
- Queue의 동작
	- first - 
	- next - 
	
- Queue의 다른 형식
	- Circlar Queue (환형 큐)
	- Priority Queue (우선순위 큐)
  
---
##### **해시 테이블 (Hash Table)**    

- **Key : Value의 형태를 갖는 자료구조**
- **모든 데이터타입으로 접근이 가능하다.***
  
- 예시 - 전화번호부
	- Key - 이름
		- 무언가를 찾기 위한 검색어
	- Value - 전화번호
		- 그 검색어로 나온 결과
- 함수
	- get
		- bool fin = hashmap.get("A");
		- 값을 읽어오고싶을때
	- put
		- HashMap.put("A", true);
	- getOrDefalut
		- getOrDefault("A", flase)
		- "A"가 있다면, A의 Value를 반환
		- 없다면 false로 처리
	  
- 어떤 문제에서 사용해야하는가?
	- String을 기반으로 정보를 기록하고 관리해야할 때
		1. 완주하지 못한 선수
			- 선수이름 -> 완주 여부
			- String -> Hash
			- String Key : bool Value
		2. 신고 결과 받기
			- 게시판 사용자
			- 신고 당한 사람을 기준으로 신고자들의 목록을 관리해야 할 때
			- 신고 당한 사람 String 
		3. 의상
			- 옷의 종류에 따라 몇개의 옵션이 있는지 세어야 할 때
			- 옷의 종류가 정수가 아니라 얼굴, 상의, 하의, 겉옷 String
			  
- 시간복잡도 Big O - O(1)
	- 아무리 데이터가 많아도 한번만 탐색하면 된다.
	
- 동작 원리
	- Hash table은 배열구조이지만 배열보다 빠른 이유는 Hash Function 덕분이다.
	- Hash Function
		1. 특정한 저장하고싶은 Key의 숫자를 바꾼다. 
		2. 그 바꾼 숫자가 index가 된다. 
		3. 거기에 Value가 저장된다.
		
	- Collision (해시 충돌)
		- 각기 다른 Key에 대하여. 해시함수가 동일한 숫자를 준 경우
			- 충돌되는 공간에 또 다른 배열을 넣는다.
				- 2개의 쌍을 저장
				- 해당 키에 해시 함수를 넣는다.
				- 해당 키로 이동
				- 그곳에서 선형 검색을 한다.
				- 이러한 이유로 항상 O(1)은 아니다.
				- 왜냐하면 충돌이 있을 경우 선형 검색을 해야하기 때문

---
##### **트리 (Tree)**

- 선형 자료 구조
	- 배열, 연결 리스트, 스택, 큐
	- 노드/원소의 앞-뒤 관계가 1대1인 구조
- 트리 자료 구조
	- 노드의 앞-뒤 관계가 1:N 또는 N:N이다.
	- 트리는 다수의 노드가 연결된 구조를 트리 라고 한다.
	- 하나의 노드가 다수의 하위 노드를 참조할 수 있다.
	- 반대로 다수의 노드가 하나의 상위 노드를 참조할 수도 있다.
	- **비선형 계층적 구조**
	
	- root (루트) - 트리 최상위 노드
	- edge (간선) - 노드와 노드 사이 연결선
	- parent (부모) - 자식 노드가 있는 노드
	- child (자식) - 부모 노드의 하위 노드
	- leaf (리프) - 트리의 가장 하위의 노드
	  
- 노드는 하나의 객체로 표현된다.
	  
- 일반적으로 두개의 속성을 지니게된다.
	1. 데이터
	2. children - 자식 노드들의 참조 정보를 저장하는 공간
	
- 트리의 구조와 용어
	- sub tree - 하나의 트리는 다수의 sub 트리로 구성된다.
			- 상위 노드 - 부모
			- 하위 노드 - 자식
	- sibling (형제) - 같은 부모를 가지고 있는 노드들
	- size (크기) - root 포함 모든 node의 수
	- depth (깊이) - node에서 root까지 거리
	- height (높이) - 노드 깊이의 최대값
		- root 노드를 기준으로 가장 깊숙히 위치한 노드까지 도착할 때 필요한 edge의 개수
	
- **binary tree (이진 트리)**
	- **각 노드가 0에서 최대 2개의 child 노드를 갖는다.**
	- 자식이 0이어도 1개여도 최대 2개를 넘지만 않으면 성립된다.
	  
- 이진트리 vs 이진 탐색 트리
	- 이진트리 조건
		- 노드의 값 노드의 데이터 크기와 상관없이 구성
	- **이진 탐색 트리 조건**
		1. **왼쪽 자식 노드 값 < 부모 노드 값**
		2. ***부모 노드 값 < 오른쪽 자식 노드 값**
	   
- 이진 트리의 최소값
	- root 기준 트리의 가장 왼쪽에 존재
	  
- 이진 트리의 최대값
	- root 기준 트리의 가장 오른쪽에 존재
	  
- tree traversal (트리 순회)
	  
	- in-order traversal (중위 순회)
		- 더이상 자식 노드가 없을 떄까지 순회 후 없을 경우 방문처리
		- `left > visit > right`
		- DFS 사용 순회 O(n)
			1. 재귀적으로 왼쪽 sub tree 순회
			2. 현재 node 방문 (ex 값 출력)
			3. 재귀적으로 오른쪽 sub tree 순화
		
	- pre-order traversal (전위 순회)
		- 노드에 방문을 먼저 해준 후에 방문 처리를 먼저한다.
		- `visit > left > right`
		- DFS 사용 순회 O(n)
			1. 현재 node 방문 (ex 값 출력)
			2. 재귀적으로 왼쪽 sub tree 순회
			3. 재귀적으로 오른쪽 sub tree 순회
		
	- post-order traversal (후위 순회)
		- 더이상 자식 노드가 없을 떄까지 순회 후 없을 경우 방문처리
		- `left > right > visit`
		- DFS 사용 순회 O(n)
			1. 재귀적으로 왼쪽 sub tree 순회
			2. 재귀적으로 오른쪽 sub tree 순회
			3. 현재 node 방문 (ex 값 출력)
	
- successor (후임자)
	- 해당 노드보다 값이 큰 노드들 중에서 가장 값이 작은 노드
	
- predecessor (선임자)
	- 해당 노드보다 값이 작은 노드들 중에서 가장 값이 큰 노드
	  
- **위의 개념과 순회 하는 방법들을 통해 이진 탐색 트리의 삽입/삭제/검색를 이해할 수 있다.**
	
- delete (삭제)
	- 삭제하려는 노드가 있는지 검색, 있으면 삭제
	- 자녀가 없는 노드 삭제
		- 삭제될 노드를 가리키던 래퍼런스를 가리키는 것이 없도록 처리
	- 자녀가 하나인 노드 삭제
		- 삭제될 노드를 가리키던 래퍼런스를 삭제될 노드의 자녀를 기리키게 변경
	- 자녀가 두개인 노드 삭제
		- 삭제될 노드의 오른쪽 서브 트리에서 제일 값이 작은 노드가 삭제될 노드를 대체한다.

---
##### **힙 (Heap)**  

- **완전이진트리를 기본으로 한 자료 구조이다.**
	  
- **A가 B의 부모노드(parent node) 이면, A의 Key값과 B의 키 값 사이에는 대소관계가 성립한다.**
	
- Heap의 종류
	- 최대 힙
		- 부모 노드의 키값이 자식노드의 키 값보다 항상 큰 힙
	- 최소 힙
		- 부모 노드의 키 값이 자식 노드의 키 값보다 항상 작은 힙
	
- **힙은 가장 높은 또는 가장 낮은 키 값이 뿌리노드(root 노드)에 오게되는 특징이 있다.**
	
- 이러한 구조를 통해 [[Priority Queue]]같은 추상적 자료형을 구현이 가능하다.
	
- Tree
	- 다수의 노드가 연결된 비선형 자료 구조
	- 부모 - 자식 의 계층 구조를 가지고 있다.
	  
- bianry tree (이진트리)
	- Heap은 이진트리를 사용한다.
	  
- 우선 순위 큐(priority queue)
	- ADT - 추상형 자료 큐
	- 가장 높은 우선 순위를 가진 데이터를 접근하거나 삭제할 때 굉장히 빠르게 접근 가능
	- 효율적인 삽입
	- O(1)의 우선 순위 요소 접근
	
- 부모 - 자식 노드의 대소 관계
	- min heap
	- max heap
	  
- heap은 배열로 표현이 가능하다.
	- root 노드가 인덱스 0에 위치할 경우
		- left - i * 2 + 1
		- right - i * 2 + 2
		- parent - (i - 1) / 2
	
- heap의 삽입 연산
	  
	- Heapify (힙의 재구조화)
		- 수행과정에서 생길수도 있는 구조의 변화로 인해 힙의 속성이 깨질 수 있기 때문에, 삽입/삭제시 힙의 재구조화를 요구된다.
		  
	- Heapify Up (버블 업)
		1. 현재 노드의 인덱스를 구한다.
		2. 현재 노드의 부모 노드의 인덱스를 구한다.
		3. 현재 노드가 부모 노드보다 크다면 두 노드를 바꾼다.
		4. 현재 노드의 인덱스를 부모 노드의 인덱스로 바꾼다.
		5. 현재 노드의 부모 노드의 인덱스를 구한다. (반복..)
	
- heap의 삭제 연산
	- Heapify Down (버블 다운)
	1. 좌측 자식 > 현재 요소 : 다음 인덱스를 좌측 자식 인덱스로 설정
	2. 우측 자식 > 현재 요소 : 다음 인덱스를 우측 자식 인덱스로 설정
	3. 다음 인덱스 != 현재 인덱스 : 현재 요소와 다음 요소를 교환하고, 다음 인덱스를 기준으로 다시 heapifyDown 호출
	
- 삽입 / 삭제 시간 복잡도
	- 삭제 및 삽입 연산의 시간 복잡도는 heap의 높이에 의해 결정
	- heap의 높이는 log n에 비례하므로 O(log n)
	  
- heap의 주요 메서드
	- peek() - 최대/최소값 리턴
	- size() - 힙 사이즈 리턴
	- isEmpty() - 힙 사이즈 0 체크
	  
- 코딩 테스트 문제
	- K 번째 큰 수
	- 가장 빈번하게 나오는 수/글자 K개
	- 출현 빈도별로 문자 정렬
	- 더 맵개
	- 이중 우선 순위 큐
	  
- 사용 언어의 Heap 구현 여부


- 종류

---


##### 자료구조 비교 정리

|자료구조|특징|주요 연산 시간 복잡도|
|---|---|---|
|**배열**|고정 크기, 연속된 메모리 공간|삽입/삭제: O(n), 조회: O(1)|
|**리스트**|동적 크기, 삽입/삭제 용이|삽입/삭제: O(1), 조회: O(n)|
|**스택**|LIFO, 후입선출|삽입/삭제: O(1), 조회: O(1)|
|**큐**|FIFO, 선입선출|삽입/삭제: O(1), 조회: O(1)|
|**해시 테이블**|키-값 쌍 저장, 충돌 해결 필요|삽입/삭제/조회: O(1) (평균)|
|**힙**|우선순위 큐, 최대/최소 힙|삽입/삭제: O(log n), 조회: O(1)|
|**이진 탐색 트리**|정렬된 데이터를 다루는 트리|삽입/삭제/검색: O(log n) (평균)|

---
##### 결론

- **배열**은 크기가 고정된 데이터에서 빠른 조회가 필요할 때 유용함.
- **리스트**는 크기가 변할 수 있는 데이터를 다루며, 삽입/삭제가 빈번한 경우 적합함.
- **스택**과 **큐**는 각각 후입선출(LIFO), 선입선출(FIFO) 방식의 데이터 처리에 적합함.
- **해시 테이블**은 빠른 키-값 검색이 필요한 경우 유용하며, **힙**은 우선순위 큐나 최대/최소 값을 다룰 때 유리함.
- **이진 탐색 트리**는 정렬된 데이터를 효율적으로 처리할 수 있으며, 균형을 유지하면 매우 효율적임.

---
# Algolism
##### **정렬 (Sorting)**

- **무언가를 정리한다.**
	
- 정렬 종류
	- **Bubble Sort**
	- **Selection Sort**
	- **Insertion Sort**
	- **Heap Sort**
	- **Merge Sort**
	- **Quick Sort**

##### 버블 정렬 Bubble Srot

- 시간복잡도
	- O(n^2)
	
- 내림차순 예시와 동작 설명
	
	1. **왼쪽 요소와 오른쪽 요소 비교**:
	    - 리스트의 첫 번째 요소와 두 번째 요소를 비교한다.
	    - **왼쪽 값이 더 작으면 교환**한다.
	        - (내림차순: 큰 값이 앞으로 오게끔 정렬)
	    - 그렇지 않으면 그대로 둔다.
	      
	2. **다음 요소로 이동**:
	    - 오른쪽으로 한 칸 이동하여 다시 비교하고 교환 여부를 결정한다.
	    - 리스트 끝까지 비교를 반복한다.
	      
	3. **끝까지 이동하면 한 사이클 완료**:
	    - 한 번의 순회가 끝나면 가장 작은 값이 리스트의 맨 뒤로 이동한다.
	    - **비교 범위를 줄이고** 다시 왼쪽부터 반복한다.
	      
	4. **필요 없을 때 멈춤**:
	    - 만약 순회 중에 교환이 한 번도 발생하지 않으면 정렬이 완료된 것으로 판단하고 멈춘다.
- 예제 코드
``` java
public class BubbleSort {
    public static void bubbleSortDescending(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) { // 전체 리스트를 반복
            boolean swapped = false; // 교환 여부 확인
            for (int j = 0; j < n - i - 1; j++) { // 점점 줄어드는 비교 범위
                if (arr[j] < arr[j + 1]) { // 내림차순: 왼쪽이 작으면 교환
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true; // 교환 발생
                }
            }
            if (!swapped) { // 교환이 없으면 정렬 완료
                break;
            }
        }
    }

    public static void main(String[] args) {
        int[] numbers = {3, 1, 4, 1, 5, 9, 2, 6, 5};
        System.out.println("정렬 전:");
        for (int num : numbers) {
            System.out.print(num + " ");
        }
        
        bubbleSortDescending(numbers);
        
        System.out.println("\n내림차순 정렬 후:");
        for (int num : numbers) {
            System.out.print(num + " ");
        }
    }
}
```

- 실행 결과
```java
정렬 전:
3 1 4 1 5 9 2 6 5 

내림차순 정렬 후:
9 6 5 5 4 3 2 1 1 
```

---
##### 선택 정렬 Selection Sort

- 시간 복잡도
	  
	- O(n2)
---
- 내림차순 예시와 동작 설명
	
1. **최대값 선택**:
    - 리스트에서 남아 있는 범위 중 가장 큰 값을 찾는다.
    - 해당 값을 **가장 왼쪽의 위치**로 이동시킨다. (스와핑)
      
2. **정렬된 범위 확장**:
    - 한 번의 순회가 끝나면 가장 큰 값이 리스트의 맨 앞에 고정된다.
    - 정렬된 범위를 확장하고, 남은 범위에서 다시 최대값을 찾는다.
      
3. **다음 위치로 반복**:
    - 두 번째로 큰 값을 두 번째 위치로 이동, 이후에도 같은 방식으로 반복한다.
      
4. **정렬 완료**:
    - 리스트의 모든 요소가 정렬될 때까지 반복한다.
	
- 예제 코드
``` java
public class SelectionSort {
    public static void selectionSortDescending(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) { // 정렬되지 않은 범위 반복
            int maxIdx = i; // 현재 범위에서 최대값의 인덱스 찾기
            for (int j = i + 1; j < n; j++) {
                if (arr[j] > arr[maxIdx]) { // 내림차순: 더 큰 값 찾기
                    maxIdx = j;
                }
            }
            // 최대값을 현재 위치로 이동
            int temp = arr[maxIdx];
            arr[maxIdx] = arr[i];
            arr[i] = temp;
        }
    }

    public static void main(String[] args) {
        int[] numbers = {3, 1, 4, 1, 5, 9, 2, 6, 5};
        System.out.println("정렬 전:");
        for (int num : numbers) {
            System.out.print(num + " ");
        }
        
        selectionSortDescending(numbers);
        
        System.out.println("\n내림차순 정렬 후:");
        for (int num : numbers) {
            System.out.print(num + " ");
        }
    }
}
```
- 실행 결과
```java
정렬 전:
3 1 4 1 5 9 2 6 5 

내림차순 정렬 후:
9 6 5 5 4 3 2 1 1 
```

---
- 선택 정렬 요약
	
1. **최대값 선택**:
    - 남아 있는 범위에서 가장 큰 값을 찾는다.
2. **최대값을 정렬된 위치로 이동**:
    - 최대값을 스와핑하여 정렬된 위치로 이동한다.
3. **남은 범위에서 반복**:
    - 정렬되지 않은 범위를 계속 줄여가며 반복한다.
4. **완료 시 정렬 결과**:
    - 내림차순일 경우, 큰 값부터 순차적으로 정렬된다.

---
##### 삽입 정렬 Insertion Sort

- **시간 복잡도**
	- O(n^2)
---

- **내림차순 예시와 동작 설명**

1. **정렬된 부분 확장**:
    
    - 리스트의 첫 번째 요소는 이미 정렬된 것으로 간주한다.
    - 두 번째 요소부터 시작해 **정렬된 부분에 올바른 위치를 찾아 삽입**한다.
2. **비교 및 이동**:
    
    - 현재 요소를 정렬된 부분의 요소들과 비교한다.
    - 내림차순이라면 **현재 요소가 더 크면 오른쪽으로 이동**한다.
3. **삽입**:
    
    - 정렬된 부분에서 현재 요소의 적절한 위치를 찾았다면 그 자리에 삽입한다.
4. **다음 요소로 이동**:
    
    - 리스트의 다음 요소를 선택하고 같은 과정을 반복한다.
5. **정렬 완료**:
    
    - 리스트 끝까지 이동하면 정렬이 완료된다.
---
- 예제 코드
```java
public class InsertionSort {
    public static void insertionSortDescending(int[] arr) {
        int n = arr.length;
        for (int i = 1; i < n; i++) { // 두 번째 요소부터 시작
            int key = arr[i]; // 삽입할 요소
            int j = i - 1;
            
            // 내림차순: 정렬된 부분에서 key보다 작은 요소들을 오른쪽으로 이동
            while (j >= 0 && arr[j] < key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key; // key를 적절한 위치에 삽입
        }
    }

    public static void main(String[] args) {
        int[] numbers = {3, 1, 4, 1, 5, 9, 2, 6, 5};
        System.out.println("정렬 전:");
        for (int num : numbers) {
            System.out.print(num + " ");
        }
        
        insertionSortDescending(numbers);
        
        System.out.println("\n내림차순 정렬 후:");
        for (int num : numbers) {
            System.out.print(num + " ");
        }
    }
}
```
- 실행 결과
```java
정렬 전:
3 1 4 1 5 9 2 6 5 

내림차순 정렬 후:
9 6 5 5 4 3 2 1 1 
```
---
- **삽입 정렬 요약**

1. **정렬된 부분 확장**:
    - 첫 번째 요소는 이미 정렬된 상태로 간주한다.
      
2. **비교 및 이동**:
    - 삽입할 위치를 찾기 위해 정렬된 부분을 순차적으로 비교하며 필요한 요소를 오른쪽으로 이동한다.
      
3. **삽입**:
    - 현재 요소를 적절한 위치에 삽입한다.
      
4. **다음 요소로 반복**:
    - 리스트 끝까지 반복하면 정렬이 완료된다.
      
5. **완료 시 정렬 결과**:
    - 내림차순일 경우, 큰 값부터 순차적으로 정렬된다.
---


##### 병합 정렬 Merge Sort

- 벙합 정렬의 동작은 **분할(Divide)**, **정복(Conquer)**, **병합(Merge)** 3단계를 반복하는 생명주기를 가지고 있다
	
- 분할 단계 (Divide)
	- 배열을 두 개의 하위 배열로 나눕니다.
	- 이 과정을 **재귀적으로** 반복하며, 배열의 크기가 1이 될 때까지 계속 나누어 갑니다.
	- 배열의 크기가 1이 되면 더 이상 나눌 수 없으므로 이 단계는 종료됩니다.
	
- 예시
	- 입력 배열
		- `[38, 27, 43, 3, 9, 82, 10]`
    - 분할 → 왼쪽: `[38, 27, 43]` / 오른쪽: `[3, 9, 82, 10]`
    - 다시 분할 → `[38]`, `[27, 43]` / `[3, 9]`, `[82, 10]`
    - 더 분할 → `[27]`, `[43]` / `[3]`, `[9]`, `[82]`, `[10]`
	- 결과적으로 각 배열이 1개 원소로 나뉘게 된다.
		- `[38]`, `[27]`, `[43]`, `[3]`, `[9]`, `[82]`, `[10]`
	
- 정복 단계 (Conquer)
	- 분할된 작은 배열들을 비교하고, 두 개씩 정렬하면서 병합을 시작합니다.
	- 작은 배열에서 큰 배열로 합쳐지며, 정렬된 상태를 유지합니다.
	- 이 과정은 재귀 호출이 종료되면서 **재귀 호출이 반환되는 순서대로** 실행됩니다.
	  
- 예시
	- `[27]`과 `[43]` 병합 → `[27, 43]`
	- `[38]`과 `[27, 43]` 병합 → `[27, 38, 43]`
	- `[3]`과 `[9]` 병합 → `[3, 9]`
	- `[82]`과 `[10]` 병합 → `[10, 82]`
	- `[3, 9]`과 `[10, 82]` 병합 → `[3, 9, 10, 82]`
	
- 병합 단계 (Merge)
	- 정렬된 하위 배열들을 다시 병합하면서 원래 크기의 배열로 합쳐나갑니다.
	- 최종적으로 모든 하위 배열이 병합되어 **완전한 정렬된 배열**이 생성됩니다.
	
- 예시
	- `[27, 38, 43]`과 `[3, 9, 10, 82]` 병합 → `[3, 9, 10, 27, 38, 43, 82]`
	
-  병합 정렬의 전체 생명주기 요약:
	1. **분할 (Divide):** 배열을 절반씩 나누어 더 이상 나눌 수 없을 때까지 반복합니다.
	2. **정복 (Conquer):** 각 하위 배열에서 정렬하면서 병합합니다.
	3. **병합 (Merge):** 병합된 하위 배열을 다시 합쳐 최종 정렬된 배열을 만듭니다.
	
- 시간복잡도
	- `O(n log n)`
	- n개 만큼씩 log n번 돌기 때문이다.
	
- 병합 정렬은 실행시에 별도의 저장공간이 필요로하다.
- 공간을 사용할 수 없는 경우는 퀵 정렬을 해야 한다.
	  
- 코드 실행시 각 단계별 진행 과정
```java
코드 실행 시 각 단계별 진행 과정

1.초기 배열 → 
	
	`[38, 27, 43, 3, 9, 82, 10]`
    
2.분할 완료 후 배열들 → 
	
	`[38]`, `[27]`, `[43]`, `[3]`, `[9]`, `[82]`, `[10]`
    
3.병합 진행 중 →
	
    - `[27] + [43]` → `[27, 43]`
    - `[38] + [27, 43]` → `[27, 38, 43]`
    - `[3] + [9]` → `[3, 9]`
    - `[82] + [10]` → `[10, 82]`
    - `[3, 9] + [10, 82]` → `[3, 9, 10, 82]`
    - `[27, 38, 43] + [3, 9, 10, 82]` → `[3, 9, 10, 27, 38, 43, 82]`
	
4. 최종 배열 → 
	
	 `[3, 9, 10, 27, 38, 43, 82]`
    
```
		  
- 예제 코드
```java
import java.util.Arrays;

public class MergeSort {

    // 병합 정렬 함수
    public static void mergeSort(int[] array) {
        // 배열의 길이가 1 이하인 경우 정렬할 필요 없음
        if (array.length < 2) {
            return;
        }
		
        // 배열을 두 부분으로 나눔
        int mid = array.length / 2;
        int[] left = Arrays.copyOfRange(array, 0, mid);
        int[] right = Arrays.copyOfRange(array, mid, array.length);
		
        // 재귀적으로 두 부분을 정렬
        mergeSort(left);
        mergeSort(right);
		
        // 두 정렬된 배열을 병합
        merge(array, left, right);
    }
	
    // 두 배열을 병합하는 함수
    public static void merge(int[] array, int[] left, int[] right) {
        int i = 0, j = 0, k = 0;
		
        // 왼쪽 배열과 오른쪽 배열을 비교하면서 작은 값을 array에 채워 넣음
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                array[k] = left[i];
                i++;
            } else {
                array[k] = right[j];
                j++;
            }
            k++;
        }
		
        // 왼쪽 배열에 남아있는 값이 있으면 넣어줌
        while (i < left.length) {
            array[k] = left[i];
            i++;
            k++;
        }
		
        // 오른쪽 배열에 남아있는 값이 있으면 넣어줌
        while (j < right.length) {
            array[k] = right[j];
            j++;
            k++;
        }
    }
	
    // 테스트용 main 함수
    public static void main(String[] args) {
        int[] array = {38, 27, 43, 3, 9, 82, 10};
        
        System.out.println("원본 배열: " + Arrays.toString(array));
        
        mergeSort(array); // 병합 정렬 수행
        
        System.out.println("정렬된 배열: " + Arrays.toString(array));
    }
}
```
	
- 학습자료
	https://www.youtube.com/watch?v=QAyl79dCO_k

##### 퀵 정렬 Quick Sort

- 정렬계 레전드
- 분할정복 알고리즘
- pivot (기준값)을 정한 뒤 피벗의 위치를 확장해가며 정렬
	
- 퀵소트의 존엄성
	- pivot
		- pivot의 기준점에 따라 속도가 다르다.
		- 가장 베스트의 기준점은 아직까지는 없다.

1. 정렬이 안되어 있는 배열이 있다.
2. 배열안에 임의의 값을 지정한다.
3. 그 값을 기준으로 그 값보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 옮긴다.
4. 파티션이 2개로 나뉜다.
5. 작은 파티션, 큰 파티션도 똑같이 반복
	   
- 시간복잡도
	- `O(n log n)`
	  
	- 퀵 정렬은 기준 값을 정해야한다.
- 가능한 중간 값을 선택하는게 좋다.
	
- 예제 코드
```java
public class QuickSort {
    // 퀵 정렬 함수
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // 피벗을 기준으로 배열을 분할
            int pivotIndex = partition(arr, low, high);
			
            // 피벗을 기준으로 배열을 두 부분으로 나누어 각각 재귀적으로 정렬
            quickSort(arr, low, pivotIndex - 1);  // 왼쪽 부분
            quickSort(arr, pivotIndex + 1, high); // 오른쪽 부분
        }
    }
	
    // 배열을 피벗을 기준으로 분할하는 함수
    public static int partition(int[] arr, int low, int high) {
        // 피벗을 배열의 마지막 원소로 선택
        int pivot = arr[high];
        int i = low - 1;
		
        // low부터 high-1까지의 배열을 순회하면서 피벗보다 작은 값을 왼쪽에, 
        // 큰 값을 오른쪽에 배치
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                // 작은 값이 나오면 i와 j를 교환
                swap(arr, i, j);
            }
        }
		
        // 피벗을 적절한 위치로 교환
        swap(arr, i + 1, high);
        return i + 1; // 피벗의 인덱스를 반환
    }
	
    // 두 원소를 교환하는 함수
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
	
    // 테스트용 main 함수
    public static void main(String[] args) {
        int[] arr = {38, 27, 43, 3, 9, 82, 10};
		
        System.out.println("원본 배열: ");
        printArray(arr);
		
        // 퀵 정렬 수행
        quickSort(arr, 0, arr.length - 1);
		
        System.out.println("정렬된 배열: ");
        printArray(arr);
    }
	
    // 배열 출력 함수
    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        System.out.println();
    }
}

원본 배열: 
38 27 43 3 9 82 10 
정렬된 배열: 
3 9 10 27 38 43 82 

```
	
- 학습 자료
	https://www.youtube.com/watch?v=7BDzle2n47c

---
##### 힙 정렬 Heap Sort

- 힙 정렬은 **힙 자료구조(Heap)** 를 이용한 정렬 알고리즘으로, 다음과 같은 생명주기를 따른다.
	
- **힙 구성 단계 (Build Heap)**
	
	- 주어진 배열을 **완전 이진 트리** 형태로 변환합니다.
	- 이 트리를 **최대 힙(Max Heap)** 또는 **최소 힙(Min Heap)**으로 재구성합니다.
	- 최대 힙: 부모 노드가 항상 자식보다 크거나 같음.  
	    최소 힙: 부모 노드가 항상 자식보다 작거나 같음.
	- 최대 힙을 사용하면 정렬이 오름차순으로 수행됩니다.
	
- 예시
	- 배열 `[38, 27, 43, 3, 9, 82, 10]` → 최대 힙으로 변환:
```java
       82
     /    \
   38      43
  /  \    /  \
 3   9  27   10
```
	
- 힙 정렬의 단계 
	- 힙의 루트(가장 큰 값)를 배열의 마지막 요소와 교환합니다.
	- 교환 후 배열의 마지막 요소를 제외하고 다시 힙을 재구성합니다.
	- 이 과정을 반복하여 정렬된 배열을 만듭니다.
	  
- 예시
	- 최대 힙에서 루트 `82`를 마지막 요소와 교환 → `[10, 38, 43, 3, 9, 27, 82]`
	- 나머지 `[10, 38, 43, 3, 9, 27]`을 최대 힙으로 재구성 → `[43, 38, 27, 3, 9, 10]`
	- 다시 루트 `43`과 마지막 요소 교환 → `[10, 38, 27, 3, 9, 43, 82]`
	- 이 과정을 반복하여 최종 정렬: `[3, 9, 10, 27, 38, 43, 82]`
	
- 힙을 재구성하고 루트를 교환하는 과정이 끝나면 배열이 정렬됩니다.
	  
-  힙 정렬 생명주기 요약
	1. **힙 구성(Build Heap):** 배열을 힙 자료구조로 변환합니다.
	2. **정렬(Sort):** 루트와 마지막 요소를 교환하고, 힙을 재구성하는 과정을 반복합니다.
	3. **완료:** 힙 정렬이 완료되면 배열이 정렬됩니다.
	
- 힙 정렬의 특징
	
	- 시간 복잡도: **O(n log n)**
	- 공간 복잡도: **O(1)** (제자리 정렬)
	- 정렬 안정성: **비안정 정렬**
	  
- 예제 코드
``` java
public class HeapSort {
	
    // 힙 정렬 함수
    public static void heapSort(int[] arr) {
        int n = arr.length;
		
        // 배열을 힙으로 만드는 과정 (최대 힙)
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
		
        // 힙에서 가장 큰 값을 배열의 끝과 교환하고, 힙을 재구성
        for (int i = n - 1; i > 0; i--) {
            // 가장 큰 원소를 배열의 마지막 원소와 교환
            swap(arr, 0, i);
			
            // 교환 후, 힙의 크기를 하나 줄이고, 힙을 재구성
            heapify(arr, i, 0);
        }
    }
	
    // 힙을 재구성하는 함수 (최대 힙을 유지)
    public static void heapify(int[] arr, int n, int i) {
        int largest = i; // 루트
        int left = 2 * i + 1; // 왼쪽 자식
        int right = 2 * i + 2; // 오른쪽 자식
		
        // 왼쪽 자식이 루트보다 크면 largest를 왼쪽 자식으로 변경
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
		
        // 오른쪽 자식이 현재 largest보다 크면 largest를 오른쪽 자식으로 변경
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
		
        // largest가 루트가 아니라면, 값을 교환하고 재귀적으로 힙을 재구성
        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, n, largest);
        }
    }
	
    // 두 원소를 교환하는 함수
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
	
    // 테스트용 main 함수
    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6, 7};
		
        System.out.println("원본 배열: ");
        printArray(arr);
		
        // 힙 정렬 수행
        heapSort(arr);
		
        System.out.println("정렬된 배열: ");
        printArray(arr);
    }
	
    // 배열 출력 함수
    public static void printArray(int[] arr) {
        for (int i : arr) {
            System.out.print(i + " ");
        }
        System.out.println();
    }
}

원본 배열: 
12 11 13 5 6 7 
정렬된 배열: 
5 6 7 11 12 13
```
	
- 학습 자료
	https://www.youtube.com/watch?v=gB7qYgikT1Y
	https://www.youtube.com/watch?v=rmtV_HcA6Oc
	https://www.youtube.com/watch?v=R7kURSaguIc

---

##### 선형탐색

- 배열에서 데이터를 찾는 알고리즘
- 이진탐색과 달리 데이터의 순서가 뒤죽박죽 나열된 경우도 적용
- 찾는 방식은 단순히 배열 앞쪽부터 순서대로 데이터를 조사한다.
- 데이터의 처음부터 선대로 비교를 반복한다.
- 따라서 데이터가 배열의 끝에 있거나 없는 경우에는 비교 횟수가 많아져서 시간이 오래 걸린다.
- 시간복잡도 - O(n)

##### 이진탐색
- 데이터가 정렬된 경우에만 적용
- 이진 탐색은 배열이 정렬된 것을 이용하여 탐색 범위를 매번 절반싹 줄여 나간다.
- 그리고 탐색 범위의 데이터가 1개가 되었을 때 탐색을 종료
- n개가 있던 데이터를 절반씩 줄이는 조작을 O log(n2)번 반복하면, 데이터가 1개가 된다.
- 즉, 이진 탐색에서는 `배열의 정중앙에 있는 수와 비교하여 탐색 범위를 절반으로 줄이는` 작업을 log(n2)회 반복하면 데이터를 찾을 수 있다. 
- 찾지 못한 경우에는 데이터가 없다고 결론 내릴 수 있다.
- 따라서 계산 시간은 O(log n)


##### 그래프
- 용어
	- 노드
		- 
	- 간선
		- 
	- 그래프
	- 
- 그래프의 다양한 표현
	- 파티에 참석한 대인관계
	- 지하철 노선도
	  
- 컴퓨터 네트워크 접속관계
	
- 가중그래프
	- 간선에 값이 붙어 있는 그래프
	- 간선에 할당된 값을 간선의 `무게`나 `비용`이라고 부른다.
	- 간선에 비용이 없으면 정점 간 연결 여부만 표현할 수 있다.
	- 비용이 있으면 연결 강도를 표현하는 것이 가능