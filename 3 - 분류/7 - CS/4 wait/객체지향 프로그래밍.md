---
created:
---

---
- 
- 
- 
---
##### 목차
1. 
2. 
3. 
---
### 1. 객체지향 프로그래밍 정의

객체지향 프로그래밍(OOP)은 **실세계의 사물을 모델링하여 프로그램을 구성하는 방식**이다. 객체지향 프로그래밍은 프로그램을 **객체**라는 독립적인 단위로 구성하고, 각 객체는 **상태(속성)**와 **행동(메서드)**을 가짐으로써, 현실 세계의 개체를 추상화하여 다룰 수 있다.

---
### 2. 특징

1. **객체 중심**: 객체지향 프로그래밍은 프로그램의 모든 요소를 객체라는 단위로 다룬다. 객체는 상태와 행동을 가짐으로써, 현실 세계의 사물을 모델링할 수 있다.
    
2. **클래스와 객체**: 클래스는 객체의 설계도를 제공한다. 객체는 클래스를 기반으로 생성되며, 클래스에서 정의된 속성과 메서드를 상속받는다. 객체는 실제로 프로그램에서 동작하는 인스턴스를 의미한다.
    
3. **상속**: 상속은 기존 클래스의 속성과 메서드를 새로운 클래스에서 재사용하는 개념이다. 상속을 통해 코드의 중복을 줄이고, 계층 구조를 형성할 수 있다.
    
4. **캡슐화**: 캡슐화는 객체의 내부 구현을 숨기고, 공개된 메서드를 통해 외부와 상호작용하는 방식이다. 이를 통해 데이터 보호와 코드의 변경 용이성을 높일 수 있다.
    
5. **다형성**: 다형성은 하나의 메서드나 객체가 여러 형태로 동작할 수 있는 특성이다. 이를 통해 유연한 코드 작성과 확장성을 제공한다.
    
6. **추상화**: 추상화는 복잡한 시스템을 단순화하여 본질적인 부분만 다루는 기법이다. 추상 클래스를 사용해 객체의 공통적인 기능을 정의하고, 세부 구현은 자식 클래스에서 처리한다.
    

---
### 3. 장점과 단점

#### 장점

1. **재사용성**: 상속을 통해 기존 클래스를 재사용할 수 있으며, 새로운 기능을 추가할 때 기존 코드에 영향을 미치지 않는다.
    
2. **유지보수성**: 캡슐화를 통해 객체의 내부 구현을 변경하더라도 외부에 미치는 영향을 최소화할 수 있다. 코드의 수정이 용이하고 유지보수가 쉬워진다.
    
3. **확장성**: 다형성과 상속을 활용하면 기존 시스템을 수정하지 않고 새로운 기능을 추가할 수 있어, 확장이 용이하다.
    
4. **직관적인 코드**: 객체지향 프로그래밍은 현실 세계의 사물을 모델링하므로 코드가 직관적이고 이해하기 쉬워진다.
    

#### 단점

1. **복잡성**: 객체지향 프로그래밍은 구조가 복잡해질 수 있으며, 많은 객체들이 상호작용하기 때문에 설계가 잘못되면 관리가 어려워질 수 있다.
    
2. **메모리 사용**: 객체지향 프로그래밍은 많은 객체를 생성하고, 각 객체마다 메모리가 할당되므로 메모리 사용이 비효율적일 수 있다.
    
3. **성능 저하**: 객체 간의 상호작용과 메서드 호출이 많아질수록 성능 저하가 발생할 수 있다.
    

---

### 4. 객체지향 프로그래밍 4대 원칙 및 예제 코드

#### 1. **상속(Inheritance)**

상속은 부모 클래스의 속성과 메서드를 자식 클래스가 물려받는 특성이다. 이를 통해 코드 재사용과 계층적 구조를 만들 수 있다.

```java
class Animal {
    void sound() {
        System.out.println("동물이 소리를 냅니다.");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("멍멍!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.sound();  // "멍멍!"
    }
}

```

#### 2. **캡슐화(Encapsulation)**

캡슐화는 객체의 데이터를 외부에서 직접 접근하지 못하도록 숨기고, 공개된 메서드를 통해 데이터에 접근하는 방식이다. 이를 통해 데이터 보호와 코드의 변경 용이성을 높일 수 있다.

```java
class Car {
    private int speed;  // 외부에서 직접 접근할 수 없음

    public int getSpeed() {
        return speed;  // getter 메서드로 속도 반환
    }

    public void setSpeed(int speed) {
        if (speed >= 0) {
            this.speed = speed;  // setter 메서드로 속도 설정
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.setSpeed(100);
        System.out.println(car.getSpeed());  // 100
    }
}
```

#### 3. **다형성(Polymorphism)**

다형성은 하나의 메서드가 여러 가지 형태로 동작할 수 있는 능력이다. 메서드 오버로딩과 메서드 오버라이딩을 통해 구현된다.

```java
class Animal {
    void sound() {
        System.out.println("동물이 소리를 냅니다.");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("멍멍!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog();
        animal.sound();  // "멍멍!" (다형성)
    }
}

```

#### 4. **추상화(Abstraction)**

추상화는 복잡한 시스템을 단순화하여 본질적인 부분만 다루는 기법이다. 추상 클래스나 인터페이스를 사용해 정의된 메서드를 자식 클래스에서 구현한다.

```java
abstract class Animal {
    abstract void sound();  // 추상 메서드
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("멍멍!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog();
        animal.sound();  // "멍멍!" (추상화)
    }
}
```

---
### 5. 잘 만든 객체지향 프로그래밍이란?

잘 만든 객체지향 프로그래밍은 **유지보수가 용이하고 확장 가능**한 구조를 가진다.
명확한 클래스 설계와 책임 분담을 통해 시스템을 **모듈화**하고, 각 객체가 자신의 역할에 맞게 동작하도록 해야 한다. 

또한, **다형성**과 **캡슐화**를 잘 활용하여 코드의 재사용성을 높이고, 외부에서 객체의 내부 구현을 변경하지 않고도 시스템을 확장하거나 수정할 수 있는 유연성을 제공한다.

잘 구조화된 객체지향 프로그램은 **명확한 클래스 관계**와 **단순한 인터페이스**를 통해 이해하기 쉽고, 유지보수가 쉬운 프로그램을 만들어준다.

---
- **출처**
	- [블로그]()
---