생성일 | {{2024-01-28}}
작성자 | 김동욱


# 14-2 페이징을 통한 가상 메모리 관리
### 요약
- 페이징은 물리 주소 공간을 프레임 단위로 자르고 프로세스의 논리 주소 공간을 페이지 단위로 자른 뒤 각 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.
- 페이지 테이블을 통해 페이지가 적재된 프레임을 찾을 수 있다. 페이지 테이블에는 페이지 번호와 프레임 번호뿐 아니라 유효 비트, 보호 비트, 접근 비트, 수정 비트 등이 있다.
- PTBR은 각 프로세스의 페이지 테이블이 적재된 주소를 가리킨다.
- TLB는 페이지 테이블의 캐시 메모리 역할을 수행하기 위해 페이지 테이블의 일부를 저장한다.
---
- 연속 메모리 할당의 두 가지 문제점
	- 외부 단편화
	- 물리 메모리보다 큰 프로세스 실행 불가 
	  
- 가상 메모리란?
	- 실행하고자하는 프로그램을 일부만 메모리에 적재해서 실제 물리 메모리보다 큰 프로세스를 실행할 수 있게 하는 기술
	  
	  
- 페이징이란?
	- 프로세스의 논리 주소 공간을 페이지라는 일정 단위로 자르고, 
	- 메모리의 물리 주소 공간을 프레임이라는 페이지와 동일한 일정한 단위로 자른 뒤
	- 페이지를 프레임에 할당하는 가상 메모리 관리 기법
	- ![[스크린샷 2024-02-03 050152.png]]![스크린샷 2024-02-03 045842 2.png](app://49a56718a0f41bddcb0e5b5fa5da2d24d688/C:/workspace/Obsidian/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-02-03%20045842%202.png?1706903990190)
	  
	  
- 페이징에서의 스와핑![[스크린샷 2024-02-03 050537.png]]
	- 프로세스를 이루고 있는 모든 페이지가 메모리내에 적재될 필요가 없다.
	- 물리 메모리보다 큰 프로세스도 실행할 수 있게 된다.
- 문제점
	- 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 일일이 알기란 어려움
	- 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 순차적으로 실행 불가
	-  CPU 입장에서 '다음에 실행할 명령어 위치'를 찾기가 어려움
	  
	  
- 페이지 테이블
	- (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도
	- (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 하는 방법
	- 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표
	  
	- 페이지 테이블 1![[스크린샷 2024-02-03 051304.png]]
		- 프로세스마다 페이지 테이블이 있다.
		  
	- 페이지 테이블 2![[스크린샷 2024-02-03 051401.png]]
		- 물리적으로 분산되어 저장되어 있더라도 CPU 입장에서 바라본 논리주소는 연속적으로 보임
		- CPU는 그저 논리 주소를 순차적으로 실행하면 될뿐이다.
		  
		  
		  
	- 내부 단편화![[스크린샷 2024-02-03 051547.png]]
	- 하나의 페이지 크기보다 작은 크기로 발생
	
	
	- 페이지 테이블 베이스 레지스터(PTBR) ![[스크린샷 2024-02-03 051932.png]]
		- 각 페이지 테이블은 CPU 내의 PTBR가 가리킨다.
		- 부작용
			- 메모리 접근 시간 두배로 증가
			- 페이지 테이블을 참조하기 위해 한번
			- 페이지를 참조하기 위해 한번
			  
			  
- TLB
	- ![[스크린샷 2024-02-03 052429.png]]
	- CPU 곁에 페이지의 테이블의 캐시 메모리
	- 페이지 테이블의 일부를 가져와
	- TLB 히트
		- CPU가 접근하려는 논리 주소가 TLB에 있다면 = TLB 히트
			- 메모리에 접근 한 번
	- TLB 미스
		- CPU가 접근하려는 논리 주소가 TLB에 없다면 = TLB 미트
			- 메모리에 접근 두 번
		
		
	- 페이징에서의 주소 변환![[스크린샷 2024-02-03 052745.png]]

	- 주소 변환에 필요한 정보  ![[스크린샷 2024-02-03 053035 1.png]]
			- 페이지번호
				- 어떤 페이지/프레임에 접근하고 싶은지
			- 변위
				- 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지
		
		
	- Quiz ![[스크린샷 2024-02-03 053342.png]]
		- 논리 주소(<페이지 번호, 변위>)가 <3, 3>
		  
		  
	- 페이지 테이블 엔트리![[스크린샷 2024-02-03 053625.png]]
		- 페이지 테이블의 각각의 행
			- 페이지 번호, 프레임 번호 
			- 이외에 다양한 정보가 있다.
			  
			  
	- 유효 비트![[스크린샷 2024-02-03 054132.png]]
		- 현재 해당 페이지에 접근 가능한지 여부
			  유효 비트 1 : 메모리에 적재된 페이지
			  유효 비트 0 : 메모리에 적재되지 않은 페이지
		- 유효 비트가 0인 페이지에 접근하려고 하면?
			- 페이지 폴트라는 인터럽트 발생
				1. CPU는 기존 작업 내역 백업
				2. 페이지 폴트 처리 루틴 실행
				3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트1로 변경
				4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근 가능
				   
				   
	- 보호 비트![[스크린샷 2024-02-03 054337.png]]
		- 페이지 보호 기능을 위해 존재하는 비트
		- 읽기(Read) | r
		- 쓰기(Write) | w
		- 실행(eXecute) | x
		  
		  
	- 참조 비트![[스크린샷 2024-02-03 054419.png]]
		- CPU가 이 페이지에 접근한 적이 있는지 여부
		  
		  
		  
	- 수정 비트 | 더티 비트![[스크린샷 2024-02-03 054508.png]]
		- CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부
		  		  
		- 왜 존재하는가?![[스크린샷 2024-02-03 054648.png]]
			- 수정된 페이지는 스왑 아웃될 때 보조기억장치에도 쓰기 작업을 거쳐야 한다.
			- 수정 비트가 1이면 보조기억장치에도 변경된 내용을 덮어씌여 반영해야한다.
---