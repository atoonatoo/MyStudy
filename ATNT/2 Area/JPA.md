

----
##### 연결 문서

- 
- 
- 
---

##### 제목 : 





- Spring Data JPA
    
    ```java
    - Spring Data JPA : 
    	"JPA를 사용하기 편하도록 만들어놓은 모듈"
    
    	* DB와 Java 간의 매핑 지원 : 
    		엔티티와 데이터베이스의 매핑을 자동으로 처리한다. 
    		엔티티 클래스를 정의하면 해당 클래스와 매핑되는 테이블이 자동으로 생성된다.		
    
    	* CURD 지원 : 
    		데이터베이스의 CURD 연산을 지원한다. 
    
    	* Repository 개발의 간편화 : 
    		Repository 인터페이스를 작성하면 Spring Data JPA가 실행 시점에 
    		해당 인터페이스에 대한 구현 객체를 동적으로 생성하며 주입한다. 
    		개발자는 직접 구현 클래스를 직접 작성하지 않아도	된다.
    
    	* DB 벤더 자동 등록 : 
    		사용중인 데이터베이스 벤더를 자동으로 감지하고, 
    		그에 맞는 JPA 구현체를 사용하도록 설정을	자동으로 처리한다.
    
    	* Spring Data JPA 내장된 메서드 제공 : 
    		특정 규칙에 따라 메서드 이름을 분석하여 자동으로 쿼리를 생성해주는 쿼리 메소드를 제공한다.
    		이를 활용하면 개발자는 단순한 메서드 이름으로 데이터베이스 조작을 수행할 수 있다.
    		(Spring Data JPA의 대표적인 기능이라고 할 수 있다.)
    
    - JPA란 그럼 무엇인가? :
    	"Java 진영에서 ORM 기술을 표준으로 사용하기 위한 인터페이스를 정의한 기술 스펙"
    	"Java Persistence API의 약자 자바의 ORM을 위한 표준 기술" 		
    	Java에서 관계형 데이터베이스와 상호 작용할 때 객체 지향적인 방식으로 데이터를	다룰 수 있도록 도와준다.
    
    - ORM은 그럼 무엇인가? : 
    	"자바의 객체와 관계형 DB를 맵핑하는 기술"
    	DB의 특정 테이블이 자바의 객체로 맵핑되어 SQL문을 일일이 작성하지 않고 
    	객체로 구현할 수 있도록 하는 프레임워크이다. 
    	
    	* 장점 : 
    		1) 코드량이 대폭 감소 
    		2) 가독성 향상
    		3) 더 간편하게 수정 가능
    		4) DB 벤더를 독립적으로 개발이 가능 
    	
    	* JPA는 반복적인 CURD SQL을 처리해준다. 
    	
    	* SQL이 아닌 객체 중심으로 개발이 가능하다.
    		이에 따라 생산성이 좋아지고 유지보수도 수월하고 
    		JPA의 패러다임 불일치도 해결한다.
    
    - ORM의 구현체 : Hibernate, Spring Data JPA 등...
    ```
    
    출처 : [https://yozm.wishket.com/magazine/detail/2160/](https://yozm.wishket.com/magazine/detail/2160/)
    
- Entity Manager
    
    ```java
    - Entity : 
    	엔티티는 데이터베이스의 테이블과 매핑되는 객체를 의미한다. 
    	엔티티는 본질적으로 일반 자바 객체이기에 일반 객체와 다르지 않다.
    	하지만, DB 테이블과 직접 연결된다는 아주 특별한 특징을 가지고 있어 구분 지어 부른다.
    	즉, 엔티티는 객체는 맞지만 DB에 영향을 미치는 쿼리를 실행하는 객체인 것이다.
    
    - Entity Manager : 
    	엔티티 매니저는 엔티티를 관리해 데이터베이스와 어플리케이션 사이에서 
    	객체의 생성, 수정, 삭제하는 등의 역할을 한다.
    	그리고 이런 엔티티 매니저 팩토리를 만드는 곳이 엔티티 매니저 팩토리(Entity Manager Factory)이다.
    
    	스프링부트는 기본적으로 빈은 하나만 생성해서 공유하므로 동시성 문제를 발생시킬 수 있다.
    	그래서 실제로 엔티티 매니저가 아닌 실제 엔티티 매니저와 연결하는 프록시(가짜) 엔티티 매니저를 사용한다.
    	필요할 때 데이터베이스 트랜잭션과 관련된 실제 엔티티 매니저를 호출하는 것이다.
    	즉, 엔티티 매니저는 Spring Data JPA에서 관리하므로 개발자가 직접 생성하거나 관리할 필요가 없다.
    ```
    
- 영속성 컨텍스트
    
    ```java
    - 영속성 컨텍스트(Persistence Context) :
    	Entity를 영구히 저장하는 공간이다.
    	애플리케이션과 DB 사이에서 객체를 보관하는 가상의 DB의 역할을 한다.
    
    	엔티티 매니저는 엔티티를 영속성 컨텍스트에 저장한다는 특징이 있다.
    	엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 
    	엔티티 매니저는 영속성 컨텍스트에 보관하고 관리하게 된다.
    	영속성 컨텍스트는 JPA의 핵심적인 특징 중 하나이다. 
    	이것이 있기에 DB의 효과적으로 데이터를 가져올 수 있으며 엔티티를 편리하게 사용할 수 있다.
    	영속성 컨텍스트는 "1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩의 특징"을 가지고있다.
    	//영속성 컨텍스트 등록
    	* em.persist(member); 
    
    - 영속성 컨텍스트의 특징 : 
    	1) 엔티티 매니저를 생성할 때 하나 만들어진다.
    	2) 엔티티 매니저를 통해서 영속성 컨텍스트에 접근하고 관리할 수 있다.
      3) 영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다. 
    		 따라서 영속 상태는 반드시 식별자 값이 있어야 한다.
    	4) JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 
    		 새로 저장된 엔티티를 데이터베이스에 반영하는데 이를 flush라 한다.
    
    	* 1차 캐시 : 
    		영속성 컨텍스트는 내부에 1차 캐시를 가지고 있다.
    		이때 캐시의 키는 엔티티의 @ID 어노테이션이 달린 기본 키 역할을 하는 식별이며 값은 엔티티이다. 
    		엔티티를 조회하면 1차 캐시에서 데이터 조회하고 값이 있으면 반환한다. 
    		이를 통해 캐시된 데이터를 조회할 때는 DB를 거치치 않아도 되므로 
    		매우 빠르게 데이터를 조회할 수 있다.
    
    	* 쓰기 지연 : 
    		트랜잭션을 커밋하기 전까지는 DB에 실제로 쿼리문을 보내지 않고 쿼리를 모았다가
    		트랜잭션을 커밋하면 모았던 쿼리를 한번에 실행하는 것을 의미한다. 
    		(GitHub의 Commit을 여러번 하고 한번에 Push 보내는 원리를 생각하면 이해하기 쉽다.)
    		// 예제 코드
    			EntityManager em = emf.createEntityManager();
    			EntityTransaction transaction = em.getTransaction();
    			//엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야 한다.
    			transaction.begin(); // [트랜잭션] 시작
    			em.persist(memberA);
    			em.persist(memberB);
    			//여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.
    			//커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.
    			transaction.commit(); // [트랜잭션] 커밋
    	
    	* 변경 감지(Dirty Checking) : 
    		트랜잭션을 커밋하면 1차 캐시에 저장되어 있는 엔티티의 값과 현재 엔티티의 값을 비교해서
    		변경된 값이 있다면 변경 사항을 감지해 변경된 값을 데이터베이스에 자동으로 반영한다. 
    		이를 통해 쓰기 지연과 마찬가지로 적당한 묶음으로 쿼리를 요청할 수 있고, 
    		DB 시스템의 부담을 줄일 수 있다.
    		// 예제 코드
    			EntityManager em = emf.createEntityManager();
    			EntityTransaction transaction = em.getTransaction();
    			transaction.begin(); // [트랜잭션] 시작
    			// 영속 엔티티 조회
    			Member memberA = em.find(Member.class, "memberA");
    			// 영속 엔티티 데이터 수정
    			memberA.setUsername("hi");
    			memberA.setAge(10);
    			//em.update(member) 이런 코드가 있어야 하지 않을까?
    			transaction.commit(); // [트랜잭션] 커밋				
    
    	* 지연 로딩(Lazy Loading) : 
    		쿼리로 요청한 어플리케이션에 바로 로딩하는 것이 아니라 
    		필요할 때 쿼리를 날려 데이터를 조회하는 것을 의미한다.
    		(반대로 조회할 때 쿼리를 보내 연관된 모든 데이터를 가져오는 즉시 로딩도 있다.)
    ```
    
    - 엔티티의 생명주기
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/11b23e09-5eeb-440a-86c3-5fb272d32444/da802084-d881-413b-ba1d-da8abf208bab/Untitled.png)
    
- 영속성 컨텍스트의 엔티티 생명주기
    
    ```java
    - 비영속성 : New / Transient
    	* 엔티티 객체를 생성
    	* 순수한 객체 상태, 아직 저장하지 않음.
    	* 영속성 컨텍스트나, 데이터베이스와 상관없음.
    	* em.persist() 호출전, 비영속 상태
    	* 코드 예시 : Member member = new Mmeber();
    							 member.setId(100L);
    							 member.setUsername("회원1");
    	
    - 영속성 : Managed
    	* 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장.
    	* 영속성 컨텍스트가 관리하는 엔티티를 영속 상태.
    	* 회원 엔티티 : 비영속 상태 => 영속 상태
    	* 영속 상태 = 영속성 컨텍스트에 의해 관리된다는 뜻.
    	* em.find()나 JPQL를 사용해서 조회한 엔티티도 영속 상태.
    	* 코드 예시 : em.persist(member);
    
    - 준영속성 : Detached
    	* 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 "준영속 상태"
    	* em.datch()호출로 준영속 상 명시적 호출.
    	* em.close()를 호출해서 영속성 컨택스를 닫음.
    	* em.clear()로 영속성 컨택스트 초기화.
    	* 코드 예시 : em.detch(memeber);
    
    - 삭제 : Removed
    	* 엔티티를 영속성 컨텍스트와 DB에서 삭
    	* 코드 예시 : em.remove(member);
    ```
    
- ORM - JPA - Hibernate - SpringDataJPA의 관계
    
    ```java
    1. ORM이란 객체와 데이터베이스를 매핑시켜주는 기술이다.
    	 ORM을 통해 우리가 정의한 객체값만으로도 데이터를 자연스럽게 연결해서
    	 연결해서 사용할 수 있게 된다.
    	 ORM없이 직접 데이터를 핸들링 한다면, Select Query를 해서 받은 결과값을
    	 일일히 Mapping해서 사용해야 한다.
    
    2. JPA는 현재 자바진영의 ORM 표준으로 체택되어있다.
    	 데이터에 접근하기 위한 API 규을 정의한 것이다.
    
    3. ORM이 전체적인 개념이라면 JPA는 그 기능을 구체적으로 정의한 기술이다.
    
    4. Hibernate란 JPA에 대한 실제 구현체인 implementation(구현)이다.
    
    5. Spring Data JPA란 스프링에서 Hibernate를 더 간편하게 사용하기 위해 
    	 추상 객체를 한번 더 감싸서 만들어 놓은 것이라고 보면 된다.
    
    6. 정리 : 
    	 * 객체 관계 매핑이란 뜻으로 자바 객체와 관계형 DB를 연결 시키는 개념이다.
    	 * 자바 진영에서 ORM의 표준 스펙으로 JPA라는 것을 인터페이스로 정의하여 제공하고 있다.
    	 * 해당 JPA의 실제 구현 클래스들을 모아놓은 것을 Hibernate라고 한다.
    	 * 이 중에 자주 쓰이는 것을 조금 더 사용하기 쉽게 스프링 프레임워크에 
    		 다시 한번 묶음으로 제공하는 것이 Spring Data JPA이다.
    ```
