---
created:
---
---
# **README**


- 목요일 8시 
	- 요구사항 분석서, ERD 
	- 기술 공부 미리하고 오기
	- 유튜브 API 미리 공부
	- 오가니제이션 미리 공부
	- 브랜치 전략 미리 공부
- 요구사항분석
	- 
- ERD 
	- 

- 우테코 리포지토리 
	- https://github.com/woowacourse-teams
- 애자일 방법론 채택한 우테코 리포지토리
	- https://github.com/woowacourse-teams/2024-code-zap?tab=readme-ov-file
- 오가니제이션 프로젝트 관리
	- https://velog.io/@gillog/GitHub-Organization-Team-%EA%B4%80%EB%A6%AC
- Git Commit 규칙
	- https://velog.io/@chojs28/Git-%EC%BB%A4%EB%B0%8B-%EB%A9%94%EC%8B%9C%EC%A7%80-%EA%B7%9C%EC%B9%99
	- [https://github.com/angular/angular/commits/master](https://github.com/angular/angular/commits/master)
- Git PR, Issue 관리
	 - https://velog.io/@pgmjun/Github-%ED%98%91%EC%97%85-%EC%9D%B4%EA%B2%83%EB%A7%8C%EC%9D%80-%EC%95%8C%EC%9E%90-Issue-PR
- Slack 관리
- Notion 관리
	- https://www.youtube.com/watch?v=L83l3zE_1PA

# 회의 
## 09/26

### 제안

### Git Oganigation, Notion, Slack 관리의 분담을 조율

##### 안건 1 : 각각 1인이 관리하고, 팀장은 모두 관리
- 장점
	- 책임분담
	- 전문성
	- 지원과 조율
	  
- 고려 사항
	- 충분한 시간을 할애
	- 도구 사용법 숙지
	- 작업량의 분담의 차이
	- 팀원 일정 상의 문제가 생기면 대신 맡아 줄 백업 계획 필요
##### 안건 2 : 격주로 돌아가면서 관리
- 장점
	- 팀원 간의 고른 경험
	- 책임 분담
	- 유연성
	- 더 나은 도구 활용
	  
- 고려사항
  
	- 순환 방식 제안
		- 격주 단위로 교체
		
		- 책임 문서화
			- 도구를 관리하는 사람은 2주 동안의 작업 내용을 간단히 기록하여 다음 팀원에게 인수인계할 수 있게 한다. 
			- 예를 들어, 어떤 이슈가 발생했고, 어떤 부분을 신경 써야 하는지 적어두면 좋다.
			  
		- 리더 역할 유지
			- 여전히 도구 관리의 전반적인 조율자 역할
			- 필요할 때 지원하는 방식으로 유지
			  
		- 시나리오
			- **1~2주차**:
			    - 팀원 A: Git Organization
			    - 팀원 B: Notion
			    - 팀원 C: Slack
			- **3~4주차**:
			    - 팀원 B: Git Organization
			    - 팀원 C: Notion
			    - 팀원 A: Slack
			- **5~6주차**:
			    - 팀원 C: Git Organization
			    - 팀원 A: Notion
			    - 팀원 B: Slack
##### 채택 안건 3 노션과 GitOganigation만 2명이서 격주로 관리




# 프로젝트 아이디어

### **프로젝트 아이디어: "프로그래밍 지식 검증 플랫폼"**

#### **프로젝트 개요**:

사용자들이 다양한 **프로그래밍 관련 지식**(예: CS 개념, 에러 해결법, 최신 뉴스 등)을 제공받고, 이를 평가하고 피드백을 줄 수 있는 플랫폼입니다. 정보를 자동으로 **여러 포털 사이트**와 **블로그**에서 수집한 후, 사용자들이 해당 정보의 **정확성**을 평가하고, 댓글이나 리뷰를 통해 논의할 수 있습니다. 사용자는 다양한 정렬 방식으로 원하는 정보를 찾아볼 수 있으며, 카테고리별로 지식을 쉽게 탐색할 수 있습니다.

---

#### **주요 기능**:

1. **지식 수집 및 분류**:
    
    - 여러 포털 사이트, 블로그 등에서 **프로그래밍 관련 게시물**을 수집하여, 카테고리(예: CS, 에러 원인 및 해결법, 최신 뉴스)별로 자동으로 분류됩니다.
    - 수집된 지식은 날짜, 출처, 카테고리 정보와 함께 **정확도 평가**를 받을 수 있는 상태로 표시됩니다.
2. **사용자 평가 및 피드백**:
    
    - 사용자는 해당 지식의 **정확성**을 평가하고 **좋아요**, **댓글** 등을 남길 수 있습니다. 다른 사용자들은 댓글을 통해 논의하고, 의견을 교환할 수 있습니다.
    - 각 게시물에는 **전문가 채택 여부**가 표시되며, 사용자들은 이를 바탕으로 신뢰할 수 있는 지식을 쉽게 식별할 수 있습니다.
3. **정렬 및 필터링**:
    
    - 사용자는 **최신순**, **정확도순**, **추천순**, **전문가 채택 여부** 등을 기준으로 게시물을 정렬할 수 있습니다.
    - 또한, **카테고리별 필터링**을 통해 자신이 원하는 주제에 맞는 정보를 쉽게 탐색할 수 있습니다.
4. **지식 정확도 점수**:
    
    - 각 게시물은 사용자들의 평가를 바탕으로 **정확도 점수**를 받습니다. 이는 **좋아요**, **전문가의 피드백**, **사용자들의 댓글** 등 다양한 요소를 기반으로 자동 계산됩니다.
    - 점수가 낮은 정보는 사용자들에게 경고 표시가 나타나고, 일정 점수 이하로 떨어지면 관리자의 검토를 거쳐 삭제되거나 수정 요청을 받을 수 있습니다.
5. **전문가 참여 및 채택**:
    
    - 프로그래밍 전문가나 인증된 사용자들이 **전문가 채택**을 할 수 있는 기능을 제공하여, 특정 지식이 신뢰할 수 있는 정보임을 표시합니다.
    - 전문가의 피드백은 사용자들의 신뢰성을 높이는 중요한 기준이 됩니다.
6. **유저 참여 보상 시스템**:
    
    - 사용자가 댓글을 남기거나, 좋아요, 평가를 하면 포인트를 획득하며, 이를 통해 레벨을 올리거나 특정 혜택(예: 광고 없음)을 받을 수 있습니다.
    - 활발히 활동한 유저는 **인증된 리뷰어**로 승격될 수 있으며, 해당 유저의 피드백은 더 높은 가중치를 가집니다.

---

#### **기술 스택과 아키텍처**:

- **프론트엔드**:
    
    - **React + Redux**: 사용자 인터페이스를 구성하고, 지식의 정렬, 평가, 피드백 시스템을 관리합니다.
    - **검색 및 필터링**: 검색 기능을 구현하고, 카테고리와 정렬 기준에 따라 필터링할 수 있는 UI를 제공합니다.
- **백엔드**:
    
    - **Spring Boot + JPA**: 지식 수집, 평가 시스템, 사용자 인증 및 평가 데이터를 관리하는 마이크로서비스를 구성합니다.
    - **웹 스크래핑**: 여러 포털 사이트와 블로그에서 **프로그래밍 관련 글**을 자동으로 수집하기 위해 Python의 **BeautifulSoup**이나 **Scrapy** 등을 활용할 수 있습니다.
    - **Lambda 함수**: 정기적으로 정보를 수집하고 평가 시스템을 관리하는 작업을 AWS Lambda로 처리합니다.
    - **MySQL**: 사용자 정보, 게시물, 평가 데이터 등을 저장하고 관리합니다.
- **DevOps**:
    
    - **Docker + AWS**: MSA 아키텍처로 구성된 각 마이크로서비스를 Docker로 컨테이너화하고, AWS 환경에서 배포합니다.
    - **CI/CD 파이프라인**: GitHub Actions 또는 Jenkins를 이용해 지속적 통합/배포 자동화를 설정하여 빠른 업데이트가 가능합니다.

---

#### **MSA 아키텍처 제안**:

- **사용자 서비스**: 회원 가입, 로그인, 평가 기록, 포인트 관리.
- **지식 수집 서비스**: 외부 포털 및 블로그에서 지식을 수집하고 카테고리별로 분류하는 서비스.
- **평가 및 댓글 서비스**: 게시물의 평가, 댓글, 피드백을 관리하는 서비스.
- **알림 서비스**: 새로운 지식 업데이트, 댓글 피드백 등의 실시간 알림 제공.
#### 문제 고려사항
##### 데이터를 가져오는 방식

###### 1. **웹 스크래핑(Web Scraping)**

**웹 스크래핑**은 웹페이지의 HTML 구조를 분석하여 데이터(게시물, 글)를 추출하는 기술입니다.

- **장점**:
    
    - 다양한 출처(포털, 블로그 등)에서 데이터를 가져올 수 있습니다.
    - API가 제공되지 않는 사이트에서도 데이터를 수집할 수 있습니다.
- **단점**:
    
    - **법적 이슈**: 일부 사이트는 스크래핑을 금지할 수 있으며, 잘못된 접근 방식은 사이트 정책 위반으로 간주될 수 있습니다.
    - **데이터 정확성 문제**: 웹페이지 구조가 변경되면 스크래핑 코드도 수정이 필요하므로 유지 관리가 복잡할 수 있습니다.
    - **성능 저하**: 실시간으로 많은 데이터를 스크래핑할 경우 성능이 저하될 수 있고, 사용자 경험에 부정적인 영향을 미칠 수 있습니다. 특히, 사이트 로딩 시간이 길어지거나, 요청이 너무 많을 경우 서비스가 불안정해질 수 있습니다.
- **해결 방안**:
    
    - **캐싱 시스템**: 수집된 데이터를 캐싱하여 사용자 경험을 개선하고, 매번 실시간으로 데이터를 가져오지 않도록 설계합니다.
    - **백엔드 작업**: 데이터를 실시간으로 수집하는 대신 주기적으로 백엔드에서 수집하고 저장하여 성능을 최적화할 수 있습니다.

###### 2. **공개 API(Application Programming Interface) 사용**

**공개 API**를 통해 포털 사이트에서 제공하는 데이터를 정식으로 받아오는 방식입니다.

- **장점**:
    
    - API를 통해 데이터를 공식적으로 받아오므로, 데이터 수집 과정에서 법적 문제나 사이트 차단이 발생할 위험이 적습니다.
    - API 사용 시, 사이트 구조 변화에 영향을 받지 않으며, 안정적인 데이터 수집이 가능합니다.
    - **속도 및 성능**: API는 빠르고 효율적이므로 사용자 경험에 긍정적인 영향을 미칩니다.
- **단점**:
    
    - 일부 사이트는 **API를 제공하지 않거나, 제한된 데이터**만 제공할 수 있습니다.
    - API 사용량에 제한이 있을 수 있어, 많은 요청을 보낼 경우 과금이 발생하거나 요청이 차단될 수 있습니다.
- **해결 방안**:
    
    - **API 요청 제한 관리**: 요청량이 많은 경우, 요청 수를 관리하거나, 백엔드에서 데이터를 주기적으로 갱신하여 실시간으로 가져오는 양을 줄입니다.

---

###### 사용자 경험에 미치는 영향

1. **성능 문제**:
    
    - **웹 스크래핑**은 실시간으로 여러 사이트에서 데이터를 수집하는 경우 성능 문제가 발생할 수 있습니다. 이는 페이지 로딩 시간 증가나 서버의 과부하로 이어질 수 있습니다. 이를 방지하기 위해 **백그라운드 작업**으로 데이터를 주기적으로 수집하고 캐싱하는 것이 좋습니다.
    - **API 사용**은 속도와 안정성 측면에서 우수합니다. 대부분의 API는 효율적이므로 사용자의 경험이 크게 저하되지 않습니다.
2. **데이터 신뢰성**:
    
    - **스크래핑**은 사이트 구조 변경 시 오류가 발생할 수 있어, 데이터 신뢰도에 영향을 줄 수 있습니다.
    - **API 사용**은 데이터가 더 안정적이고 최신 정보일 가능성이 큽니다.
3. **유지 관리**:
    
    - 웹 스크래핑 방식은 사이트가 업데이트될 때마다 구조가 변경될 수 있어 유지 관리가 복잡해질 수 있습니다. 반면 API 방식은 이러한 문제가 적습니다.

---

###### 최적의 방법 제안:

- **혼합 방식**을 고려할 수 있습니다. API를 제공하는 사이트는 **API**를 사용하여 데이터를 수집하고, API가 없는 사이트에 한해서 **스크래핑**을 적용하는 방식입니다.
- **백엔드에서 주기적으로 데이터를 수집**한 후, 이를 캐싱하거나 데이터베이스에 저장하여 사용자에게 빠른 응답을 제공하도록 합니다. 이로써 실시간 스크래핑의 부담을 줄이고 성능을 최적화할 수 있습니다.
##### 법적 이슈는 어떻게 해결하는가

**웹 스크래핑**이나 **API**를 통해 데이터를 수집할 때 **법적 이슈**는 중요한 문제입니다. 잘못된 방법으로 데이터를 수집할 경우 **저작권 침해**, **서비스 약관 위반** 또는 **컴퓨터 사기 및 남용법 위반** 등의 법적 문제가 발생할 수 있습니다. 이를 해결하기 위해서는 **적법한 절차**를 따르고, 사전에 **법적 검토**를 통해 문제가 없는지 확인하는 것이 중요합니다.

###### 법적 이슈 해결 방법:

###### 1. **서비스 약관 확인 및 준수**

- **포털 사이트**나 **블로그**의 서비스 약관을 먼저 확인해야 합니다. 많은 사이트들은 **서비스 약관(TOS, Terms of Service)**에서 웹 스크래핑에 대한 규정을 명시하고 있으며, 스크래핑을 금지하는 경우도 있습니다.
- 약관에서 웹 스크래핑이 명시적으로 금지되어 있거나, 승인 없이 데이터 수집이 금지된 경우에는 스크래핑을 하지 않는 것이 원칙입니다.

###### 2. **공개 API 활용**

- 가능하면 웹 스크래핑 대신 **공식 API**를 사용하는 것이 가장 안전한 방법입니다. 공식 API를 사용하는 것은 서비스 제공자가 허가한 방식이므로 **법적 위험**이 없습니다.
- API 사용 시에는 해당 API 제공자가 제시하는 **사용 제한**(요청 횟수, 데이터 범위 등)을 준수해야 합니다.

###### 3. **저작권 이슈 검토**

- **콘텐츠**(텍스트, 이미지, 동영상 등)를 수집할 때는 저작권법을 준수해야 합니다. 웹에서 수집한 콘텐츠는 원칙적으로 저작권이 적용될 수 있으며, 이를 **상업적 목적으로 사용**할 경우 저작권 침해 소송에 휘말릴 수 있습니다.
- 따라서 수집된 콘텐츠를 **상업적 이용**보다는 정보 제공 목적(비영리적 목적)으로 사용하는 것이 안전합니다. 필요한 경우, 저작권자에게 **사용 허가**를 요청하는 것도 방법입니다.

###### 4. **로봇 배제 표준(Robots.txt) 준수**

- 많은 웹사이트는 **로봇 배제 표준(Robots.txt)** 파일을 통해 웹 크롤러가 접근할 수 있는 페이지를 지정합니다. 이 파일을 통해 사이트 소유자는 특정 페이지에 대한 스크래핑이나 크롤링을 제한할 수 있습니다.
- `robots.txt` 파일에서 스크래핑이 허용된 부분만 접근하도록 설정하여, 웹사이트의 정책을 따르는 것이 좋습니다.

###### 5. **저작권자와의 협의**

- 특정 사이트나 블로그에서 데이터를 자주 수집해야 하는 경우, **저작권자** 또는 **사이트 운영자**와 협의하여 **허가**를 받을 수 있습니다. 이를 통해 데이터를 적법하게 사용할 수 있는 권리를 확보할 수 있습니다.
- 데이터 제공자가 별도의 데이터 제공 계약을 체결할 수도 있습니다.

###### 6. **비영리적 사용**

- 데이터 수집 목적이 **비영리적**이거나 **연구 및 학습**을 위한 경우, 저작권 이슈가 완화될 수 있습니다. 다만, 이 경우에도 수집된 데이터를 상업적 목적으로 사용하거나 재배포하는 것은 문제가 될 수 있으니 주의가 필요합니다.

###### 7. **서비스 제공자에게 요청**

- 웹사이트 운영자가 스크래핑을 허용하지 않지만 API도 제공하지 않는다면, **직접 데이터 제공을 요청**할 수 있습니다. 종종 웹사이트 운영자들은 협력 관계를 맺고 데이터를 제공할 수 있습니다.

###### 8. **법적 자문 구하기**

- 데이터 수집 및 사용에 대한 법적 문제가 우려된다면, 변호사나 법률 전문가에게 **법적 자문**을 구하는 것이 좋습니다. 저작권법이나 각국의 개인정보 보호법(CCPA, GDPR 등)을 이해하는 것이 필요합니다.

---

###### 요약:

- **서비스 약관**과 **저작권법**을 준수하는 것이 가장 중요합니다. 웹 스크래핑이 허용되지 않는 사이트에서는 **공식 API**를 활용하거나 **사이트 운영자와 협의**하는 것이 필요합니다.
- **저작권 문제**를 피하기 위해서는 데이터를 **비영리적 목적**으로 사용하고, 필요하다면 **저작권자에게 사용 허가**를 받는 것이 좋습니다.
- **법적 자문**을 구하여 데이터 수집 및 사용에 있어 안전하게 프로젝트를 진행하는 것이 장기적으로 유리합니다.



# 애자일 적용 예시

### 1. **프로젝트 목표 및 요구사항 정의**

#### **프로젝트 목표**:

- **Inflearn**과 유사한 IT 커뮤니티 플랫폼을 개발.
- 사용자들은 IT 관련 강의를 업로드하고, 질문을 통해 상호작용하며 커뮤니티 활동에 참여.

#### **주요 기능**:

- 사용자 등록 및 인증 (소셜 로그인 포함)
- 강의 목록 및 강의 상세 페이지
- 강의 업로드 및 관리
- 커뮤니티 게시판 (질문 및 답변, 게시글)
- 강의 리뷰 및 평점
- 알림 및 메시지 시스템

#### **프로덕트 백로그**:

1. 사용자 인증 시스템 (로그인/회원가입)
2. 강의 업로드/관리 기능
3. 커뮤니티 게시판 기능
4. 강의 리뷰 및 평점 시스템
5. 사용자 대시보드 및 통계
6. 알림 시스템 (강의 등록, 새 게시물 등)
7. 소셜 로그인 기능
8. 관리자 페이지 (강의/사용자 관리)

---

### 2. **스프린트 계획 (Sprint Planning)**

#### **첫 번째 스프린트 목표**:

- 사용자 인증 시스템과 기본적인 강의 목록 페이지를 완성.

#### **스프린트 백로그**:

- 회원가입 및 로그인 기능 구현
- 강의 목록 페이지 UI 설계
- 강의 데이터베이스 스키마 설계
- 강의 목록 API 개발
- 강의 데이터 표시

---

### 3. **스프린트 진행 (Sprint Execution)**

#### **일일 스탠드업**:

매일 15분 동안 팀원들이 모여 각자의 작업 상황, 문제점, 계획을 공유.

- **Frontend 팀원**: 강의 목록 페이지 디자인과 로그인 폼 작업.
- **Backend 팀원**: 회원가입 및 로그인 API 개발, 데이터베이스 설계 및 연동 작업.

#### **개발 및 협업**:

- **Frontend**: React 및 Tailwind CSS를 사용하여 사용자 인터페이스를 디자인하고, 로그인 및 회원가입 폼을 구현.
- **Backend**: Spring Boot와 JPA를 사용하여 사용자 데이터베이스 및 인증 API 구현. JWT 인증 방식 적용.
- **API 연결**: 로그인 성공 시 사용자의 정보를 받아오는 API 연동.

---

### 4. **스프린트 리뷰 (Sprint Review)**

#### **데모**:

- 팀은 회원가입 및 로그인 기능과 기본 강의 목록 페이지를 고객(또는 이해관계자)에게 데모로 보여줌.
- 고객 피드백: 회원가입 및 로그인 UI를 좀 더 직관적으로 수정 요청. 강의 목록에 추가 필터 기능 필요.

#### **피드백 반영**:

- UI 개선 사항과 강의 목록 필터 기능을 다음 스프린트로 이동.
- 새로운 요구사항을 백로그에 추가하고 우선순위 재정렬.

---

### 5. **스프린트 회고 (Sprint Retrospective)**

#### **팀 회고**:

- **잘된 점**: API 연동이 순조롭게 진행되었고, 사용자 인증이 잘 작동.
- **개선할 점**: UI 디자인에 시간이 예상보다 많이 소요되었음. 향후 UI 작업에 대한 명확한 일정 배분 필요.

#### **개선 계획**:

- UI 설계와 백엔드 API 통합 과정에 더 빠른 피드백 루프 적용.
- 주요 기능에 대한 마이크로 단위의 작업 배분 강화.

---

### 6. **두 번째 스프린트 계획 (Sprint Planning)**

#### **두 번째 스프린트 목표**:

- 강의 업로드 기능과 커뮤니티 게시판 기본 기능 구현.

#### **스프린트 백로그**:

- 강의 업로드 폼 제작 (파일 업로드 포함)
- 커뮤니티 게시판 UI 설계
- 강의 업로드 API 개발
- 커뮤니티 게시판 게시글 작성 기능
- 강의 목록 필터 기능 추가 (카테고리, 난이도별 필터)

---

### 7. **반복 (Iteration)**

#### **다음 스프린트**:

이후에도 위 과정이 반복되며, 점차적으로 기능을 추가하고 고객 피드백을 반영해 플랫폼을 발전시킵니다.

- 강의 리뷰 및 평점 기능 추가
- 소셜 로그인 연동 (Google, Kakao)
- 알림 시스템 구축
- 관리자 페이지 개발

---

### 결론:

애자일 방법론을 적용하면 **Inflearn 벤치마킹 IT 커뮤니티 플랫폼** 개발이 반복적으로 진행되며, 빠르게 변화하는 요구사항에 유연하게 대응할 수 있습니다. 팀은 각 스프린트에서 우선순위가 높은 기능을 구현하고, 피드백을 반영하여 프로젝트를 점진적으로 완성해 나갑니다.


# Git Commit 규칙

![[Pasted image 20240926150835.png]]




## Commit message 7가지 규칙

1. 제목과 본문을 한 줄 띄어 구분
2. 제목은 50자 이내
3. 제목 첫 글자는 대문자
4. 제목 끝에 마침표 X
5. 제목은 명령문으로, 과거형 X
6. 본문의 각 행은 72자 이내 (줄바꿈 사용)
7. 본문은 어떻게 보다 무엇을, 왜에 대하여 설명

## Commit message 구조

기본적으로 commit message 는 제목, 본문, 꼬리말로 구성합니다.  
제목은 필수사항이며, 본문과 꼬리말은 선택사항입니다.

```null
<type>: <subject>

<body>

<footer>
```

### Type

- feat : 새로운 기능 추가, 기존의 기능을 요구 사항에 맞추어 수정
- fix : 기능에 대한 버그 수정
- build : 빌드 관련 수정
- chore : 패키지 매니저 수정, 그 외 기타 수정 ex) .gitignore
- ci : CI 관련 설정 수정
- docs : 문서(주석) 수정
- style : 코드 스타일, 포맷팅에 대한 수정
- refactor : 기능의 변화가 아닌 코드 리팩터링 ex) 변수 이름 변경
- test : 테스트 코드 추가/수정
- release : 버전 릴리즈

### Subject

Type 과 함께 헤더를 구성합니다. 예를들어, 로그인 API 를 추가했다면 다음과 같이 구성할 수 있습니다.

`ex) feat: Add login api`

### Body

헤더로 표현이 가능하다면 생략이 가능합니다. 아닌 경우에는 자세한 내용을 함께 적어 본문을 구성합니다.

### Footer

어떠한 이슈에 대한 commit 인지 issue number 를 포함합니다. 위의 좋은 예시에서는 `(#1)` 처럼 포함시켰습니다. 그리고 `close #1` 처럼 close 를 통해 해당 이슈를 닫는 방법도 있습니다.

## References

- [좋은 커밋 메세지 작성하기위한 규칙들](https://beomseok95.tistory.com/328)
- [Git Commit Message Style Guide - 개인/팀을 위한 커밋 메시지 스타일 가이드](https://blog.munilive.com/posts/my-git-commit-guide.html)








# Git PR , Issue 관리


# INFO
- 왜 MSA를 사용하는 결정을 했는지 스스로 설명할 수 있는게 베스트
# DDD

1. **도메인의 중요성**: 
	DDD는 소프트웨어 설계 시 도메인 로직을 중심으로 구조화합니다. 도메인은 비즈니스 문제를 해결하기 위한 핵심 요소이며, 개발자와 비즈니스 관계자가 공유하는 **보편 언어(ubiquitous language)**를 사용해 커뮤니케이션합니다.
    
2. **Bounded Context**: 
	도메인의 경계를 명확히 설정하여 모호성을 제거합니다. 한 도메인 내에서 정의된 개념이 다른 도메인에 영향을 주지 않도록 **경계를 나누는 것**이 중요합니다.
    
3. **컨텍스트 맵(Context Map)**: 
	여러 도메인이 존재할 때 이들 간의 관계를 시각화합니다. **각 도메인의 책임과 역할을 명확히 하여** 협업 중 발생할 수 있는 문제를 줄입니다.
    
4. **애그리게이트(Aggregates)**: 
	엔티티와 값 객체를 그룹화하여 **같은 라이프사이클을 갖는 단위로 관리**합니다. 이를 통해 복잡한 도메인 논리를 간소화하고 일관성을 유지할 수 있습니다.
    
5. **응용 서비스(Application Services)**: 
	도메인 로직을 외부에서 호출할 수 있는 서비스로, 비즈니스 로직을 **응용 계층과 인프라 계층으로 분리**하여 유지보수를 쉽게 합니다.
    
6. **육각형 아키텍처(Hexagonal Architecture)**: 
	**비즈니스 로직을 외부 인프라(데이터베이스, UI 등)로부터 독립시킴으로써** 코드를 모듈화하고 유지보수가 용이하도록 만듭니다.
    
- 이 외에도 게시물에서는 실질적인 프로젝트에 DDD를 적용한 사례를 통해 구체적인 설계 방법을 설명하고 있습니다. 
- 더 자세한 내용은 [해당 블로그](https://kakaoentertainment-tech.tistory.com/95)에서 확인하실 수 있습니다.

# 애자일 방법론

- 신속한 반복 작업을 통해 실제 작동 가능한 소프트웨어를 개발하여 지속적으로 제공하기 위한 소프트웨어 개발 방식
- 사전적인 의미 : `날렵한`, `민첩한`
- 애자일 방법론은 `폭포수형 모델`에 반대되는 개념으로 탄생한 방법론
- 폭포수 모델은 소프트웨어 개발 계획을 정해두고 각각의 단계별로 개발을 진행하는 형태의 개발 방법론이다.
- 떄문에 중간에 문제가 생긴다면 처음부터 다시 각각의 단계를 진행해야 한다.
	- **지나치게 계획에 의존하고 있으며 형식적인 절차를 따르기 때문에 시간도 오래 걸리고 그 효율성이 크게 저하된다는 단점이 있다.
- 반면 애자일 방법론은 꾸준히 고객의 반응을 반영하면서 소프트웨어를 개발하는 방법론으로 문서기반의 개발보다는 **실질적인 코딩을 통한 방법론**이다.
	- **미례를 예측하기 보다는 주기적으로 제작 프로토타입을 시험해보는 철저한 관리를 통한 개발 방법론이라 할 수 있으며 끊임없이 개발하고 수정하는 일을 반복하면서 고객이 가장 만족할 수있는 방향으로 개발한다.

### 애자일 방법론 VS 기존 방법론

|        |                                |                                |
| ------ | ------------------------------ | ------------------------------ |
| 구분     | 애자일(Agile) 방법론                 | 기존 방법론                         |
| 요구사항관리 | 지속적인 요구사항 개발 및 변경수용            | 초기 요구사항 수집 및 엄격한 변경관리          |
| 계획 수립  | 두단계 계획(찾은 계획 수립&갱신) 경험 기반 프로세스 | 상세한 계획 수립(Up-Front) 계획 기반 프로세스 |
| 설계     | 적시(Just-in-time)설계             | 상세한 사전(Up-Front) 설계            |
| 문서화    | 경량 프로세스 및 문서화보다 코드를 강조         | 중량 프로세스 및 상세한 문서화 강조           |
| 역할     | 전체 팀워크를 중요시                    | 엄격한 역할 분리                      |

### 애자일 방법론 VS 워터폴 방법론

##### 워터폴 방법론

- 폭포수 방법론이라고도 불리며 각 작업이 폭포처럼 위에서 아래로 떨어지는 단계별 개발 방법론
- 요구 사항 정의 (설계) -> 디자인 -> 개발 -> 테스트 -> 배포의 과정
- 순차적으로 진행
![[Pasted image 20240924144724.png]]

- 워터폴 방법론 장단점
	- 장점
		- 단계별로 업무를 분담하기 때문에 맡은 바가 명확하다.
		- 계획 단계의 문서화로 단계마다 소요되는 시간이 현재 상황을 추적하고 병목을 파악하기 쉽다.
	- 단점
		- 속도가 느리고 유연하지 못하다.

##### 애자일 방법론

- `기민한`, `민첩한` 이라는 뜻
- 일정한 주기를 가지고 빠르게 제품을 출시하여 고객의 요구사항, 변화된 환경에 맞게 여구를 더 하고 수정해나가는 탄력적인 방법론
- 변화하는 고객 요구 사항에 대응하는 민첩한 개발 방식

![[Pasted image 20240924144949.png]]

### 애자일 방법론의 가치성

- 공정과 도구보다 **개인과 상호작용을**
- 포괄적인 문서보다 **작동하는 소프트웨어를**
- 계약 협상보다 **고객과의 협력을**
- 계획을 따르기보다 **변화에 대응하기를**
	
### 애자일 방법론 프로세스

- 일반적으로 오늘날 많은 기업은 Scrum과 같은 애자일 프로세스를 주로 활용
- 짧은 사이클로 제품을 개발하고 테스트하고 피드백을 받아 보완하는 방식
- 변화에 수동적으로 대처하기보다 변화를 하나의 고정값을 전제하여 1~4주 작은 스프린트 단위로 디자인 -> 개발 -> 테스트를 진행

![[Pasted image 20240924145255.png]]

##### 애자일 방법론 장단점

- 장점
	- 첫 단계에서 모든 요구사항을 계획하고 분석하지 않기 때문에 디자인, 개발, 배포까지 신속하게 완수할 수 있다.
	- 계획에 의존하지 않고 일정한 주기마다 그때그때 요구사항을 반영하고 수정하여 시장과 고객의 변화에 대응하기 쉽다.
	- 


### 애자일 방법론 실천하는 방법

1. 짧은 스프린트 주기
	- 2주 단위의 스프린트를 설정한다.
	- 매번 배포 가능한 결과물을 목표로 한다.
2. 데일리 스탠드업 미팅
	- 매일 짧은 회의를 통해 진행 상황과 장애물을 공유
3. 지속적 피드백
	- 주기적인 리뷰를 통해 개선점을 즉시 반영
4. 작업 분할
	- 프론트엔드와 백엔드는 기능별로 작업을 나누고, 서로 명확히 정의된 API로 협력
5. 칸반 보드 사용
	- Notion, Jira 같은 툴로 작업 흐름을 시각화하고 관리
# Lamda

### 정의

- 함수형 프로그래밍은 함수를 중심으로 프로그램을 구성하는 방식
- 함수는 일급 객체로 다룬다.
- 이는 함수를 변수에 저장하거나 다른 함수의 인자로 전달, 반환 가능
- 자바에서는 다음과 같은 함수형 프로그래밍 구현 가능
	- **람다 표현식 (임명 함수)**
	- **스트림 API** (데이터를 함수형 방식으로 처리)
### 람다 표현식 기본

##### 기본 문법
```java
(매개변수) -> 표현식

// 기존 방식: 익명 클래스를 사용한 Runnable 구현
Runnable r1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("기존 방식");
    }
};

// 람다 표현식으로 간단하게 작성
Runnable r2 = () -> System.out.println("람다 방식");
```
- 람다식을 사용하여 동일한 기능을 더 간단하게 구현할 수 있다.

##### 람다 표현식에서 매개변수 사용

- 람다 표현식은 매개변수를 사용할 수도 있다.
- 다음은 매개변수를 받아 두 수를 더하는 함수
```java
// 기존 방식: 익명 클래스로 구현
BinaryOperator<Integer> sum1 = new BinaryOperator<Integer>() {
    @Override
    public Integer apply(Integer a, Integer b) {
        return a + b;
    }
};

// 람다 표현식으로 간단하게 구현
BinaryOperator<Integer> sum2 = (a, b) -> a + b;

```

##### 스트림 API 사용
- 자바 8에서 스트림 API를 통해 데이터를 함수형 스타일로 처리 가능
- 예시로 리스트에 있는 숫자를 필터링하고 합계를 구하는 방식
```java
import java.util.Arrays;
import java.util.List;

public class StreamExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);

        // 기존 방식: for-each 루프를 사용한 필터링
        int sum = 0;
        for (int num : numbers) {
            if (num > 3) {
                sum += num;
            }
        }
        System.out.println("기존 방식 합계: " + sum);

        // 스트림 API를 사용한 필터링 및 합계
        int streamSum = numbers.stream()
                               .filter(num -> num > 3) // 3보다 큰 숫자만 필터링
                               .mapToInt(num -> num)   // 정수형으로 매핑
                               .sum();                 // 합계 계산

        System.out.println("스트림 방식 합계: " + streamSum);
    }
}
```

- 이 예시에서는 숫자 리스트에서 3보다 큰 숫자들을 필터링한 후, 그 합계를 구하는 과정을 보여준다.

##### 람다 표현식과 스트림의 장점

- 간결성
	- 코드가 간결해지고 가독성이 좋아진다.
- 재사용성
	- 함수형 프로그래밍은 코드를 모듈화하고, 재사용할 수 있는 함수를 쉽게 만든다.
- 벙렬처리
	- 스트림 API는 병렬 처리를 쉽게 지원하여 성능을 향상시킬 수 있다.

##### 람다 표현식이 어려운 이유

- **익숙하지 않은 문법
	- 자바의 명령형 프로그래밍 스타일에 익숙해왔기에 함수형 프로그래밍 패러다임의 도입이 처음에는 낯설게 느껴질 수 있다.
```JAVA
// 전통적인 익명 클래스 방식
new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello");
    }
};

// 람다 표현식
() -> System.out.println("Hello");

```

- **추상화 수준 증가
	- 람다식은 코드의 추상화 수준을 높인다.
	- 간결하고 재사용이 가능하다는 장점이 있지만, 동시에 더 많은 추상적 개념을 이해해야 한다는 의미
	- 특히, 람다식은 **함수형 인터페이스**와 연관되며, 이를 이해해야 코드가 명확하게 다가온다.
	- **함수형 인터페이스
		- 람다식은 함수형 인터페이스(메서드가 하나인 인터페이스)를 기반으로 동작
		- 이 개념이 익숙하지 않다면 어려움을 느낄 수 있다.
```JAVA
@FunctionalInterface
interface MyFunction {
    void execute();
}

// 람다식으로 인터페이스 구현
MyFunction func = () -> System.out.println("실행");
```

- **메서드 참조 및 고차 함수 개념
	- 람다식의 강력한 기능 중 하나인 **메서드 참조**와 **고차 함수** 개념이다.
	- 그러나 이 개념들은 함수형 프로그래밍에 익숙하지 않은 사람들에게는 난해할 수 있다.
```JAVA
// 기존 방식
numbers.forEach(num -> System.out.println(num));

// 메서드 참조 방식
numbers.forEach(System.out::println);
```

- **상태 변화 관리 어려움
	- 람다식과 함수형 프로그래밍은 불변성을 중시한다.
	- 이는 변수를 변경하지 않고 상태를 유지하는 방식
	- 자바의 전통적인 방식에서 벗어남
	- 람다식으로 코드를 작성할 때 변수 상태 관리가 기존의 방식과 달라 혼란을 줄 수 있다.
```JAVA
int sum = 0;
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);

// 전통적인 방식
for (int num : numbers) {
    sum += num;
}

// 함수형 방식 (람다식과 스트림)
int sum2 = numbers.stream().mapToInt(Integer::intValue).sum();
```

- **디버깅 어려움
	- 간결한 표현이 가능하지만 함수형 프로그래밍이라는 사고방식의 전환을 요구
	- 기존의 명령형 프로그래밍 스타일에서는 코드가 상태를 변경하고, 순차적으로 동작한다.
	- 하지만 함수형 프로그래밍은 순수 함수, 불변성, 상태 변경 최소화 원칙을 따른다.
	- 이러한 사고방식 변화가 어려움을 느끼게 할 수 있다.

##### 람다 함수를 사용하기 적절한 상황

- 간결성, 명확성, 재사용성이 중요한 상황에 특히 유용

##### 간단한 익명 함수가 필요한 경우
```JAVA
// 기존 방식: 익명 클래스를 사용
Runnable r1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello World");
    }
};

// 람다식 방식
Runnable r2 = () -> System.out.println("Hello World");

```
##### 컬렉션을 처리할 때 (스트림 API와 함께)
```JAVA
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// 필터링 후 결과 출력
names.stream()
     .filter(name -> name.startsWith("A"))
     .forEach(System.out::println);

```

##### 이벤트 핸들러와 콜백 함수
```JAVA
// 버튼 클릭 이벤트에 람다식 적용
button.addActionListener(e -> System.out.println("Button clicked!"));
```

##### 함수형 인터페이스를 사용할 때
```JAVA
// Comparator 예시
Comparator<Integer> comparator = (a, b) -> a.compareTo(b);

```

### 적절하지 않은 경우

##### 복잡한 로직에 부적합

- 복잡한 로직, 다수의 조건문, 반복문을 포함하는 경우 오히려 가독성을 떨어뜨리고 디버깅이 어려움
```JAVA
// 복잡한 로직은 람다식보다 메서드로 구현하는 것이 더 좋습니다
public int calculateSomething(int x) {
    if (x > 10) {
        return x * 2;
    } else {
        return x - 5;
    }
}

```

##### 재사용성의 한계

- 람다식은 익명 함수이기 때문에 재사용성이 떨어진다.
- 동일한 로직을 여러 번 사용헤야 한다면, 람다식보다는 명시적인 메서드로 분리를 권장
```JAVA
// 중복되는 로직을 메서드로 분리
public int processNumber(int num) {
    return num * 2 + 1;
}

List<Integer> numbers = Arrays.asList(1, 2, 3);
numbers.stream()
       .map(this::processNumber)  // 재사용 가능한 메서드 호출
       .forEach(System.out::println);

```

### 언제 람다식을 피해야 하는가

- 복잡한 로직을 처리할 때
- 여러 가지 작업을 처리해야 할 때
- 디버깅이 중요한 경우

# QueryDSL

### 정의

- **타입 안전한** 쿼리를 작성할 수 있도록 도와주는 Java 기반의 프레임워크
- JPA, SQL 등 여러 DB 접근 방식에서 사용할 수 있으며, SQL 문법과 유사한 방식으로 쿼리를 자바 코드로 표현 가능
- 주요 특징 중 하나가 **타입 안전성**을 제공
- 컴파일 시점에 쿼리에서 발생할 수 있는 오류를 미리 확인할 수 있다.

### 기본 개념 및 역할

- **타입 안전한 쿼리 작성
	- JPQL이나 SQL로 쿼리 작성시 문자열 기반이기 때문에 오류를 런타임에서만 발견할 수 있다.
	- QueryDSL은 자바 객체와 메서드를 사용하여 쿼리를 작성하므로 컴파일 시점에 잘못된 시점에 잘못된 쿼리를 감지할 수 있다.
- **간결한 직관적인 쿼리 작성
	- SQL 쿼리와 유사한 문법을 사용
	- 복잡한 쿼리도 쉽게 읽고 유지 관리를 도운다.
- **다양한 데이터베이스 지원
	- JPA뿐만 아니라, SQL, MongoDB, Hibernate 등 다양한 DB와 함께 사용 가능
- **빌더 패턴 기반의 쿼리 작성
	- QueryDSL은 빌더 패턴을 기반으로 쿼리 작성
	- 이 패턴은 메서드를 체인처럼 연결하여 쿼리를 만들어 나가는 방식
	- 가독성을 높이고 코드를 간결하게 유지

### QureyDSL 기본 기능

- 간단한 조회 쿼리 작성

```JAVA
JPAQueryFactory queryFactory = new JPAQueryFactory(entityManager);
QUser user = QUser.user;

List<User> users = queryFactory.selectFrom(user)
    .where(user.age.gt(18))
    .fetch();
```

- 조건부 쿼리
	- 다양한 조건을 체인으로 연결하여 복잡한 쿼리를 작성
```JAVA
queryFactory.selectFrom(user)
    .where(user.name.eq("Kim"), user.age.between(20, 30))
    .fetch();

```

- JOIN
	- 여러 테이블 간의 조인도 쉽게 처리할 수 있다.
```java
QOrder order = QOrder.order;
QProduct product = QProduct.product;

List<Order> orders = queryFactory.selectFrom(order)
    .join(order.product, product)
    .where(product.price.gt(1000))
    .fetch();
```

- 페이징 및 정렬
	- QueryDSL 쿼리에 페이징과 정렬 기능을 쉽게 추가
```JAVA
queryFactory.selectFrom(user)
    .orderBy(user.name.asc())
    .offset(0)
    .limit(10)
    .fetch();
```
- 이름 기준으로 오름차순 정렬 후 , 첫 번째 페이지에 해당하는 10개의 데이터를 조회

### QueryDSL 주요 장점

- **타입 안정성
	- 컴파일 타임에 쿼리의 오류를 감지 가능
- **가독성
	- 빌더 패턴을 통해 쿼리를 직관적이고 간결하게 작성할 수 있다.
- **유연성
	- 복잡한 조건이나 조인 쿼리도 쉽게 처리 가능
# Q 클래스

### 정의

- QClass는 **QueryDSL**에서 쿼리를 작성할 때 사용되는 **자동 생성된 자바 클래스**이다.
- 이 클래스는 JPA Entity Class에 기반하여 만들어진다.
- SQL 쿼리를 작성할 떄 필드와 테이블을 **타입 안전하게** 참조할 수 있도록 도와준다.

### QClass의 역할

- **타입 안전한 쿼리 작성
	- Q클래스는 QueryDSL에서 SQL 쿼리의 필드와 테이블을 **객체지향적인 방식**으로 접근할 수 있게 한다.
	- 전통적인 JPQL이나 SQL에서는 문자열로 필드나 테이블을 참조하기 때문에 오타나 오류가 컴파일 시점에 잡히지 않지만, Q클래스를 사용하면 자바 객체를 사용하여 필드와 테이블을 참조하므로, 컴파일 시점에 오류를 발견할 수 있다.
- **자동생성
	- Q클래스는 **QueryDSL 플러그인**을 통해 자동으로 생성
	- 즉, 엔티티 클래스가 있을 때 이를 기반으로 Q클래스가 생성
	- 이 과정은 보통 `maven`이나 `gradle` 빌드시 이루어진다.
	- 생성된 Q클래스는 `target/generated-sources` 같은 디렉토리 안에 위치
- **엔티티 클래스와 연동
	- Q클래스는 JPA 엔티티 클래스에 대한 참조를 제공하는 역할
	- 예시로`User`라는 엔티티 클래스가 있을 때, `QUser`라는 이름의 Q클래스가 자동으 생성된다.
	- 이를 통해 QueryDSL에서 `QUser.user.username`과 같은 형식으로 쿼리를 작성할 수 있다.

##### QClass 구조 예시

- User Entity Class
```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;
    private String password;

    // Getters and Setters
}
```

- 자동생성된 Quser Class
```java
// QUser.java
public class QUser extends EntityPathBase<User> {
    public static final QUser user = new QUser("user");

    public final StringPath username = createString("username");
    public final StringPath password = createString("password");

    public QUser(String variable) {
        super(User.class, forVariable(variable));
    }

    public QUser(Path<? extends User> path) {
        super(path.getType(), path.getMetadata());
    }

    public QUser(PathMetadata metadata) {
        super(User.class, metadata);
    }
}
```

### QClass에서 제공하는 주요 기능

- 필드 접근
	- Q클래스는 엔티티의 필드를 타입에 맞는 객체로 변환
	- 예를들어, `username`은 `StringPath`로 변환되어 `QUser.user.username`과 같이 사용
- 타입에 맞는 메서드 제공
	- QueryDSL은 각 필드의 타입에 맞는 연산 메서드를 제공
	- 예를들어, `StringPath`는 `eq(), contains(), startWith()`와 같은 문자열 연산 메서드를 사용할 수 있다.
	- `NumberPath`는 `gt(), lt()`와 같은 숫자 연산 메서드를 제공


##### QClass를 이용한 쿼리 작성 예시

```java
// AuthService.java
@Service
public class AuthService {

    private final JPAQueryFactory queryFactory;

    @Autowired
    public AuthService(JPAQueryFactory queryFactory) {
        this.queryFactory = queryFactory;
    }

    public Optional<User> login(String username, String password) {
        QUser user = QUser.user;

        User foundUser = queryFactory.selectFrom(user)
                .where(user.username.eq(username)
                        .and(user.password.eq(password)))
                .fetchOne();

        return Optional.ofNullable(foundUser);
    }
}
```
# 크롤링

- Web Crawler 또는 Spider라는 자동화된 프로그램을 사용하여 인터넷 상의 웹페이지를 자동으로 수집하는 작업
- 주로 검색 엔진(구글, 네이버 등)이 웹페이지를 수집하고 인덱싱하는데 사용되며, 데이터 수집, 가격 비교, 트렌드 분석 등의 목적으로도 활용
# Redux
# AWS

### 정의


# AWS Lambda