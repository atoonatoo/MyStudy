---
created:
---
---

# Data Structure

## **1. 자료구조를 사용하는 이유**

1. **효율적인 데이터 처리와 문제 해결을 하기 위해서**
   
2. **자료 구조는 데이터를 어떻게 저장하고 관리할지를 정의**
   
3. **자료 구조는 특정 작업을 효율적으로 처리 할 수 있도록 설계**

	1. 데이터 접근과 처리의 효율성
		- 배열, 리스트 - 빠른 조회
		- 스택, 큐 - 순서대로 처리
		- 해시 테이블 - 빠른 키-값 검색 제공
		  
	2. 메모리 사용 최적화
		- 연결 리스트 - 동적 메모리 할당
		- 배열 - 빠른 메모리 접근
		- 해시 테이블 - 빠른 키-값 검색 제공
		- 힙 - 우선순위 큐 처리
		  
	3. 알고리즘 최적화
		- 이진 탐색 트리 - 효율적인 검색, 삽입, 삭제
		- 그래프는 최단 경로 탐색
		- 힙 - 우선순위 큐 구현
		  
	4. 작업 순서와 데이터 우선순위 처리
		- 스택 - 후입선출
		- 큐 - 선입선출
		- 힙 - 우선순위 큐 처리
		  
    5. 문제 해결, 추상화
	    - 문제를 단순화
	    - 알고리즘을 이해하기 쉽게 만든다.
	      
	6. 성능 최적화
		- 배열 - 빠른 조회
		- 연결 리스트 - 삽입, 삭제 빈번할 경우
		- 해시 테이블은 빠른 검색, 삽입, 삭제
		- 힙은 우선순위 큐
	    
	7. 다양한 문제 해결
		- 그래프 - 소셜 네트워크, 도로 네트워크 분석
		- 트리 - 계층적 데이터 처리
		  
    - 결론
	    - 효율적인 데이터 저장
	    - 문제 해결 최적화
	    - 성능 개선
	    - 적합한 자료 구조 선택은 알고리즘 효율성, 메모리 사용, 실행 시간을 최적화할 수 있다.

---
## **2. 자료 구조 종류**

- [[Linked List]]
- [[Array]]
- [[Stack]]
- [[Queue]]
- [[Hash Table]]
- [[Heap]]
- [[Binary Search Tree, BST]]
- 

---

##### **스택 (Stack)**  

- **데이터를 쌓아올리는 구조 방식**
- **FILO (First In Last Out, 선입후출)** : 처음에 오는 데이터가 제일 마지막에 나감
- **LIFO(Last In First Out, 후입선출)** : 제일 마지막에 들어온 데이터가 제일 먼저 나감
	- 같은 말이지만 LIFO를 자주 표현에 사용
- 데이터를 처리하는 방식으로 네트워크나 시스템에 많이 사용
- 대표적인 예 
	- 실행 취소 : Ctrl + Z
	- 웹브라우저 뒤로가기
	- 계산기
	- 햄버거 놀이
	
- 대표적인 스택 구현 방법
	
	- 1차원 배열 (정적)
		- 장점 - 구현은 상대적으로 쉽다.
		- 단점 - 인풋 사이즈를 미리 알아야한다.
	- 리스트 (동적)
		- 장점 - 구현은 상대적으로 어렵다.
		- 단점 - 재한된 사이즈로부터 자유롭다.
	
- 스택의 주요 기능
	  
	- Push
		- 스택에 데이터를 추가하는 함수
	- Pop
		- 스택에 최상위 데이터를 빼내어서 가져오는 기능
		
	- Peak(Top)
		- 제일 최근에 들어간 데이터, 최상위 데이터
		  
	- 택시기사
		- 요금을 지불할 때 동전을 넣고(push) 빼고(pop) 한다.

---

##### **큐 (Queue)**  

- **제일 먼저 들어온 값이 제일 먼저 나가는 구조**
- **FIFO (First In Fisrt Out, 선입선출)**

- 대표적안 사용사례
	- 프로세스 스케줄링
	- 대부분의 입출력 (ex 파일 입출력 등)
	- 프린트 대기열
	- 네트워크 패킷 처리
	- 게임 대기열 (ex 로아, 오버워치)
	
- 구현하는 방법
	- Array (정적) 
		- (ex Fixed Array)
		- 구현이 쉽다.
		- 고정된 Queue 크기
	- Array (동적)
		- (ex Linked List)
		- 자유로운 Queue 크기
		- 구현이 약간 더 어렵다.
	  
- 대표적인 함수
	- Enqueue - 큐에 값을 집어넣는 함수
	- Dequeue - 큐에서 값을 뺴내는 함수
	- size - 큐의 크기를 확인하는 함수
	- empty - 큐가 비어있는지 확인하는 함수
	  
- Queue의 동작
	- first - 
	- next - 
	
- Queue의 다른 형식
	- Circlar Queue (환형 큐)
	- Priority Queue (우선순위 큐)
  

---

##### **해시 테이블 (Hash Table)**    

- **Key : Value의 형태를 갖는 자료구조**
- **모든 데이터타입으로 접근이 가능하다.***
  
- 예시 - 전화번호부
	- Key - 이름
		- 무언가를 찾기 위한 검색어
	- Value - 전화번호
		- 그 검색어로 나온 결과
- 함수
	- get
		- bool fin = hashmap.get("A");
		- 값을 읽어오고싶을때
	- put
		- HashMap.put("A", true);
	- getOrDefalut
		- getOrDefault("A", flase)
		- "A"가 있다면, A의 Value를 반환
		- 없다면 false로 처리
	  
- 어떤 문제에서 사용해야하는가?
	- String을 기반으로 정보를 기록하고 관리해야할 때
		1. 완주하지 못한 선수
			- 선수이름 -> 완주 여부
			- String -> Hash
			- String Key : bool Value
		2. 신고 결과 받기
			- 게시판 사용자
			- 신고 당한 사람을 기준으로 신고자들의 목록을 관리해야 할 때
			- 신고 당한 사람 String 
		3. 의상
			- 옷의 종류에 따라 몇개의 옵션이 있는지 세어야 할 때
			- 옷의 종류가 정수가 아니라 얼굴, 상의, 하의, 겉옷 String
			  
- 시간복잡도 Big O - O(1)
	- 아무리 데이터가 많아도 한번만 탐색하면 된다.
	
- 동작 원리
	- Hash table은 배열구조이지만 배열보다 빠른 이유는 Hash Function 덕분이다.
	- Hash Function
		1. 특정한 저장하고싶은 Key의 숫자를 바꾼다. 
		2. 그 바꾼 숫자가 index가 된다. 
		3. 거기에 Value가 저장된다.
		
	- Collision (해시 충돌)
		- 각기 다른 Key에 대하여. 해시함수가 동일한 숫자를 준 경우
			- 충돌되는 공간에 또 다른 배열을 넣는다.
				- 2개의 쌍을 저장
				- 해당 키에 해시 함수를 넣는다.
				- 해당 키로 이동
				- 그곳에서 선형 검색을 한다.
				- 이러한 이유로 항상 O(1)은 아니다.
				- 왜냐하면 충돌이 있을 경우 선형 검색을 해야하기 때문
##### **트리 (Tree)**

- 선형 자료 구조
	- 배열, 연결 리스트, 스택, 큐
	- 노드/원소의 앞-뒤 관계가 1대1인 구조
- 트리 자료 구조
	- 노드의 앞-뒤 관계가 1:N 또는 N:N이다.
	- 트리는 다수의 노드가 연결된 구조를 트리 라고 한다.
	- 하나의 노드가 다수의 하위 노드를 참조할 수 있다.
	- 반대로 다수의 노드가 하나의 상위 노드를 참조할 수도 있다.
	- **비선형 계층적 구조**
	
	- root (루트) - 트리 최상위 노드
	- edge (간선) - 노드와 노드 사이 연결선
	- parent (부모) - 자식 노드가 있는 노드
	- child (자식) - 부모 노드의 하위 노드
	- leaf (리프) - 트리의 가장 하위의 노드
	  
- 노드는 하나의 객체로 표현된다.
	  
- 일반적으로 두개의 속성을 지니게된다.
	1. 데이터
	2. children - 자식 노드들의 참조 정보를 저장하는 공간
	
- 트리의 구조와 용어
	- sub tree - 하나의 트리는 다수의 sub 트리로 구성된다.
			- 상위 노드 - 부모
			- 하위 노드 - 자식
	- sibling (형제) - 같은 부모를 가지고 있는 노드들
	- size (크기) - root 포함 모든 node의 수
	- depth (깊이) - node에서 root까지 거리
	- height (높이) - 노드 깊이의 최대값
		- root 노드를 기준으로 가장 깊숙히 위치한 노드까지 도착할 때 필요한 edge의 개수
	
- **binary tree (이진 트리)**
	- **각 노드가 0에서 최대 2개의 child 노드를 갖는다.**
	- 자식이 0이어도 1개여도 최대 2개를 넘지만 않으면 성립된다.
	  
- 이진트리 vs 이진 탐색 트리
	- 이진트리 조건
		- 노드의 값 노드의 데이터 크기와 상관없이 구성
	- **이진 탐색 트리 조건**
		1. **왼쪽 자식 노드 값 < 부모 노드 값**
		2. ***부모 노드 값 < 오른쪽 자식 노드 값**
	   
- 이진 트리의 최소값
	- root 기준 트리의 가장 왼쪽에 존재
	  
- 이진 트리의 최대값
	- root 기준 트리의 가장 오른쪽에 존재
	  
- tree traversal (트리 순회)
	  
	- in-order traversal (중위 순회)
		- 더이상 자식 노드가 없을 떄까지 순회 후 없을 경우 방문처리
		- `left > visit > right`
		- DFS 사용 순회 O(n)
			1. 재귀적으로 왼쪽 sub tree 순회
			2. 현재 node 방문 (ex 값 출력)
			3. 재귀적으로 오른쪽 sub tree 순화
		
	- pre-order traversal (전위 순회)
		- 노드에 방문을 먼저 해준 후에 방문 처리를 먼저한다.
		- `visit > left > right`
		- DFS 사용 순회 O(n)
			1. 현재 node 방문 (ex 값 출력)
			2. 재귀적으로 왼쪽 sub tree 순회
			3. 재귀적으로 오른쪽 sub tree 순회
		
	- post-order traversal (후위 순회)
		- 더이상 자식 노드가 없을 떄까지 순회 후 없을 경우 방문처리
		- `left > right > visit`
		- DFS 사용 순회 O(n)
			1. 재귀적으로 왼쪽 sub tree 순회
			2. 재귀적으로 오른쪽 sub tree 순회
			3. 현재 node 방문 (ex 값 출력)
	
- successor (후임자)
	- 해당 노드보다 값이 큰 노드들 중에서 가장 값이 작은 노드
	
- predecessor (선임자)
	- 해당 노드보다 값이 작은 노드들 중에서 가장 값이 큰 노드
	  
- **위의 개념과 순회 하는 방법들을 통해 이진 탐색 트리의 삽입/삭제/검색를 이해할 수 있다.**
	
- delete (삭제)
	- 삭제하려는 노드가 있는지 검색, 있으면 삭제
	- 자녀가 없는 노드 삭제
		- 삭제될 노드를 가리키던 래퍼런스를 가리키는 것이 없도록 처리
	- 자녀가 하나인 노드 삭제
		- 삭제될 노드를 가리키던 래퍼런스를 삭제될 노드의 자녀를 기리키게 변경
	- 자녀가 두개인 노드 삭제
		- 삭제될 노드의 오른쪽 서브 트리에서 제일 값이 작은 노드가 삭제될 노드를 대체한다.


##### **힙 (Heap)**  

- **완전이진트리를 기본으로 한 자료 구조이다.**
	  
- **A가 B의 부모노드(parent node) 이면, A의 Key값과 B의 키 값 사이에는 대소관계가 성립한다.**
	
- Heap의 종류
	- 최대 힙
		- 부모 노드의 키값이 자식노드의 키 값보다 항상 큰 힙
	- 최소 힙
		- 부모 노드의 키 값이 자식 노드의 키 값보다 항상 작은 힙
	
- **힙은 가장 높은 또는 가장 낮은 키 값이 뿌리노드(root 노드)에 오게되는 특징이 있다.**
	
- 이러한 구조를 통해 [[Priority Queue]]같은 추상적 자료형을 구현이 가능하다.
	
- Tree
	- 다수의 노드가 연결된 비선형 자료 구조
	- 부모 - 자식 의 계층 구조를 가지고 있다.
	  
- bianry tree (이진트리)
	- Heap은 이진트리를 사용한다.
	  
- 우선 순위 큐(priority queue)
	- ADT - 추상형 자료 큐
	- 가장 높은 우선 순위를 가진 데이터를 접근하거나 삭제할 때 굉장히 빠르게 접근 가능
	- 효율적인 삽입
	- O(1)의 우선 순위 요소 접근
	
- 부모 - 자식 노드의 대소 관계
	- min heap
	- max heap
	  
- heap은 배열로 표현이 가능하다.
	- root 노드가 인덱스 0에 위치할 경우
		- left - i * 2 + 1
		- right - i * 2 + 2
		- parent - (i - 1) / 2
	
- heap의 삽입 연산
	  
	- Heapify (힙의 재구조화)
		- 수행과정에서 생길수도 있는 구조의 변화로 인해 힙의 속성이 깨질 수 있기 때문에, 삽입/삭제시 힙의 재구조화를 요구된다.
		  
	- Heapify Up (버블 업)
		1. 현재 노드의 인덱스를 구한다.
		2. 현재 노드의 부모 노드의 인덱스를 구한다.
		3. 현재 노드가 부모 노드보다 크다면 두 노드를 바꾼다.
		4. 현재 노드의 인덱스를 부모 노드의 인덱스로 바꾼다.
		5. 현재 노드의 부모 노드의 인덱스를 구한다. (반복..)
	
- heap의 삭제 연산
	- Heapify Down (버블 다운)
	1. 좌측 자식 > 현재 요소 : 다음 인덱스를 좌측 자식 인덱스로 설정
	2. 우측 자식 > 현재 요소 : 다음 인덱스를 우측 자식 인덱스로 설정
	3. 다음 인덱스 != 현재 인덱스 : 현재 요소와 다음 요소를 교환하고, 다음 인덱스를 기준으로 다시 heapifyDown 호출
	
- 삽입 / 삭제 시간 복잡도
	- 삭제 및 삽입 연산의 시간 복잡도는 heap의 높이에 의해 결정
	- heap의 높이는 log n에 비례하므로 O(log n)
	  
- heap의 주요 메서드
	- peek() - 최대/최소값 리턴
	- size() - 힙 사이즈 리턴
	- isEmpty() - 힙 사이즈 0 체크
	  
- 코딩 테스트 문제
	- K 번째 큰 수
	- 가장 빈번하게 나오는 수/글자 K개
	- 출현 빈도별로 문자 정렬
	- 더 맵개
	- 이중 우선 순위 큐
	  
- 사용 언어의 Heap 구현 여부


- 종류

---


---
### 자료구조 비교 정리

|자료구조|특징|주요 연산 시간 복잡도|
|---|---|---|
|**배열**|고정 크기, 연속된 메모리 공간|삽입/삭제: O(n), 조회: O(1)|
|**리스트**|동적 크기, 삽입/삭제 용이|삽입/삭제: O(1), 조회: O(n)|
|**스택**|LIFO, 후입선출|삽입/삭제: O(1), 조회: O(1)|
|**큐**|FIFO, 선입선출|삽입/삭제: O(1), 조회: O(1)|
|**해시 테이블**|키-값 쌍 저장, 충돌 해결 필요|삽입/삭제/조회: O(1) (평균)|
|**힙**|우선순위 큐, 최대/최소 힙|삽입/삭제: O(log n), 조회: O(1)|
|**이진 탐색 트리**|정렬된 데이터를 다루는 트리|삽입/삭제/검색: O(log n) (평균)|

---


---
### 결론

- **배열**은 크기가 고정된 데이터에서 빠른 조회가 필요할 때 유용함.
- **리스트**는 크기가 변할 수 있는 데이터를 다루며, 삽입/삭제가 빈번한 경우 적합함.
- **스택**과 **큐**는 각각 후입선출(LIFO), 선입선출(FIFO) 방식의 데이터 처리에 적합함.
- **해시 테이블**은 빠른 키-값 검색이 필요한 경우 유용하며, **힙**은 우선순위 큐나 최대/최소 값을 다룰 때 유리함.
- **이진 탐색 트리**는 정렬된 데이터를 효율적으로 처리할 수 있으며, 균형을 유지하면 매우 효율적임.

---