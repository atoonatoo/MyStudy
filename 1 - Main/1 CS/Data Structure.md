---
created:
---

##### 자료 구조를 사용하는 이유

- 자료구조를 사용하는 이유는 **효율적인 데이터 처리**와 **문제 해결**을 위한 최적화 때문이다. 
- 자료구조는 데이터를 어떻게 저장하고 관리할지를 정의하며, 각각의 자료구조는 특정 작업을 효율적으로 처리할 수 있도록 설계되어 있다.
  
1. **데이터 접근과 처리의 효율성**  
    배열, 리스트는 빠른 조회, 스택과 큐는 순서대로 처리, 해시 테이블은 빠른 키-값 검색 제공.
    
2. **메모리 사용 최적화**  
    연결 리스트는 동적 메모리 할당, 배열은 빠른 메모리 접근, 힙은 우선순위 큐 처리.
    
3. **알고리즘 최적화**  
    이진 탐색 트리는 효율적인 검색, 삽입, 삭제, 그래프는 최단 경로 탐색, 힙은 우선순위 큐 구현.
    
4. **작업 순서와 데이터 우선순위 처리**  
    스택은 후입선출, 큐는 선입선출, 힙은 우선순위 큐 처리.
    
5. **문제 해결과 추상화**  
    문제를 단순화하고 알고리즘을 이해하기 쉽게 만듬.
    
6. **성능 최적화**  
    배열은 빠른 조회, 연결 리스트는 삽입/삭제 빈번, 해시 테이블은 빠른 검색/삽입/삭제, 힙은 우선순위 큐에 적합.
    
7. **다양한 문제 해결**  
    그래프는 소셜 네트워크, 도로 네트워크 분석, 트리는 계층적 데이터 처리.
    
- 결론
	자료구조는 **효율적인 데이터 저장**, **문제 해결 최적화**, **성능 개선**을 위해 사용된다. 
	적합한 자료구조 선택으로 **알고리즘 효율성**, **메모리 사용**, **실행 시간**을 최적화할 수 있다.
  
##### **자료 구조 종류**

1. **리스트 (List)**  
    리스트는 순서대로 데이터를 저장할 수 있는 자료구조이다. 데이터 크기가 변할 수 있어 동적으로 데이터를 다룰 수 있음.  
    배열 기반 리스트는 연속된 메모리 공간에 데이터를 저장하며, 인덱스를 통해 빠르게 조회할 수 있음. 크기 변경이 불편하고, 삽입/삭제가 시간이 많이 걸림.  
    연결 리스트는 노드가 데이터를 저장하고 다음 노드를 가리키는 포인터를 포함하여 동적 크기 조정이 가능함. 삽입/삭제는 용이하지만, 탐색은 O(n) 시간이 걸림.
    
2. **배열 (Array)**  
    배열은 고정 크기의 데이터를 연속된 메모리 공간에 저장하는 자료구조이다. 인덱스를 이용한 빠른 데이터 접근이 가능하며, O(1) 시간 복잡도로 조회할 수 있음.  
    장점: 빠른 조회, 고정된 크기의 데이터에 적합.  
    단점: 크기 변경 불가, 삽입/삭제 시 O(n) 시간이 걸림.
    
3. **스택 (Stack)**  
    스택은 LIFO(Last In, First Out) 방식으로 동작하는 자료구조이다. 가장 최근에 삽입된 데이터부터 처리됨.  
    주요 연산: 삽입(push), 삭제(pop), 조회(peek)  
    장점: 삽입과 삭제가 O(1) 시간 복잡도로 빠름.  
    단점: 중간 데이터를 조회하거나 삭제할 수 없음.
    
4. **큐 (Queue)**  
    큐는 FIFO(First In, First Out) 방식으로 동작하는 자료구조이다. 먼저 들어온 데이터가 먼저 나감.  
    주요 연산: 삽입(enqueue), 삭제(dequeue), 조회(peek)  
    장점: 삽입과 삭제가 O(1) 시간 복잡도로 빠름.  
    단점: 중간 데이터를 조회하거나 삭제할 수 없음.
    
5. **해시 테이블 (Hash Table)**  
    해시 테이블은 키-값 쌍으로 데이터를 저장하는 자료구조이다. 해시 함수를 사용하여 빠른 데이터 접근이 가능함.  
    구현: 키를 해시 함수로 변환하여 데이터를 저장하고, 충돌 해결 방식을 사용함.  
    장점: 평균적으로 O(1) 시간 복잡도로 삽입, 조회, 삭제가 가능함.  
    단점: 해시 충돌이 많을 경우 성능 저하가 발생할 수 있음.
    
6. **힙 (Heap)**  
    힙은 우선순위 큐를 구현하기 위한 자료구조로, 완전 이진 트리 형태로 구성됨. 최대 힙(Max-Heap)과 최소 힙(Min-Heap)으로 나뉨.  
    주요 연산: 삽입, 삭제, 조회  
    장점: 삽입과 삭제는 O(log n) 시간 복잡도이며, 빠른 최대/최소 값 검색이 가능함.  
    단점: 임의의 값에 대한 검색은 O(n) 시간이 걸림.
    
7. **이진 탐색 트리 (Binary Search Tree, BST)**  
    이진 탐색 트리는 왼쪽 자식 노드는 부모 노드보다 작은 값을, 오른쪽 자식 노드는 부모 노드보다 큰 값을 가지는 정렬된 트리이다.  
    주요 연산: 삽입, 삭제, 검색  
    장점: 정렬된 데이터를 효율적으로 처리할 수 있으며, O(log n) 시간 복잡도로 삽입/삭제/검색이 가능함(평균적인 경우).  
    단점: 트리가 불균형하면 O(n) 시간이 걸릴 수 있음.
    

---

### 자료구조 비교 정리

|자료구조|특징|주요 연산 시간 복잡도|
|---|---|---|
|**배열**|고정 크기, 연속된 메모리 공간|삽입/삭제: O(n), 조회: O(1)|
|**리스트**|동적 크기, 삽입/삭제 용이|삽입/삭제: O(1), 조회: O(n)|
|**스택**|LIFO, 후입선출|삽입/삭제: O(1), 조회: O(1)|
|**큐**|FIFO, 선입선출|삽입/삭제: O(1), 조회: O(1)|
|**해시 테이블**|키-값 쌍 저장, 충돌 해결 필요|삽입/삭제/조회: O(1) (평균)|
|**힙**|우선순위 큐, 최대/최소 힙|삽입/삭제: O(log n), 조회: O(1)|
|**이진 탐색 트리**|정렬된 데이터를 다루는 트리|삽입/삭제/검색: O(log n) (평균)|

---

### 결론

- **배열**은 크기가 고정된 데이터에서 빠른 조회가 필요할 때 유용함.
- **리스트**는 크기가 변할 수 있는 데이터를 다루며, 삽입/삭제가 빈번한 경우 적합함.
- **스택**과 **큐**는 각각 후입선출(LIFO), 선입선출(FIFO) 방식의 데이터 처리에 적합함.
- **해시 테이블**은 빠른 키-값 검색이 필요한 경우 유용하며, **힙**은 우선순위 큐나 최대/최소 값을 다룰 때 유리함.
- **이진 탐색 트리**는 정렬된 데이터를 효율적으로 처리할 수 있으며, 균형을 유지하면 매우 효율적임.