---
title: portpolio version 1.1
type: resume
director: employ
date: 2025-10-31
tags:
  - programing
  - employment
  - resume
---
## 1. 부하 테스트 설계와 도구 선정

프로젝트의 안정성과 확장성을 검증하기 위해 실제 사용자 행위를 모사한 복합 시나리오 기반 부하 테스트를 설계했습니다. Spring Security 로그인부터 JWT 및 리프레시 토큰 발급, 무작위 플레이리스트 조회, 내부 동영상 반복 조회로 이어지는 단계별 API 흐름을 구성하고, 요청 간 데이터 의존성과 인증 연속성을 검증했습니다.

k6, Locust, nGrinder 등 다양한 부하 테스트 도구를 검토한 결과, Apache JMeter를 선택했습니다. 다른 도구들은 모두 스크립트를 직접 작성하는 코드 기반 방식이지만, JMeter는 테스트 플랜 내의 JSON Extractor, Header Manager, CSV Data Set Config, ForEach Controller 등 다양한 요소를 통해 로그인, 토큰 추출, 데이터 주입, 반복 호출 과정을 시각적으로 구성할 수 있었습니다.

이를 통해 복잡한 인증 시나리오도 코드 작성 없이 자동화할 수 있었으며, 테스트 시나리오 작성 및 유지보수 시간을 약 ???% 단축했습니다. 실제 사용자 2만 명 규모의 동시 부하 환경을 재현하여 로그인 처리량, JWT 인증 속도, 응답 시간, 에러율을 측정했습니다. 그 결과 로그인 구간의 병목을 식별하고, 이후 Nginx 분산 구조 도입의 필요성을 검증했습니다. 테스트 결과 응답 속도는 평균 ???ms 단축, 에러율은 ???% 감소했습니다.

---

## 2. Nginx 기반 로드 밸런싱 및 트래픽 제어

부하 테스트 결과 단일 서버 구조의 한계가 확인되어 Nginx를 도입했습니다. Nginx는 HTTP 계층에서 요청 큐잉, keep-alive, 헤더 정규화, rate-limit 등 다양한 트래픽 제어 기능을 제공하며, 업스트림 정책을 통해 트래픽을 균등 분배할 수 있었습니다.

HAProxy는 설정 복잡도, AWS ALB는 비용, Traefik은 컨테이너 환경 종속성이 높아 제외했습니다. Nginx 도입 이후 요청 응답 속도는 평균 ???ms 단축, 트래픽 분산 효율은 ???% 향상되었습니다. rate-limit 기능으로 인증 요청 폭주 시에도 안정적인 서비스 품질을 유지했으며, keep-alive 재사용률이 증가해 CPU와 네트워크 부하가 감소했습니다. 에러율은 초기 ???%에서 ???%로 안정화되었습니다.

---

## 3. 로그 수집 및 분석 체계 (EFK 스택)

Elasticsearch, Filebeat, Kibana로 구성된 EFK 스택을 도입해 로그 수집부터 색인, 시각화까지 통합했습니다. Filebeat은 로그 변화를 실시간 감지하고, Elasticsearch는 역색인 구조로 대용량 로그 본문을 빠르게 검색하며, Kibana는 실시간 대시보드 분석을 지원했습니다.

이전에는 병목 구간 로그 추적에 수시간이 소요되었으나, 도입 후 평균 분석 시간이 ???분으로 단축되었습니다. 오류 발생 시점 감지 속도는 ???% 개선되었고, 다중 서버 환경에서도 로그 손실 없이 실시간 분석이 가능해졌습니다.

---

## 4. HikariCP 커넥션 풀 튜닝

로그 분석 결과 DB 연결 풀 고갈이 병목의 주요 원인이었습니다. HikariCP, Apache DBCP2, Tomcat JDBC Pool, c3p0를 비교한 결과, 내부 락 경합이 적고 연결 회수 속도가 빠른 HikariCP를 선택했습니다. connectionTimeout, leakDetectionThreshold를 통해 누수와 지연을 즉시 감지했고, idleTimeout으로 불필요한 연결을 자동 정리했습니다.

도입 이후 로그인 처리 평균 응답 시간은 ???ms에서 ???ms로 단축되었고, 에러율은 ???% 감소했습니다.

---

## 5. Redis 캐싱 도입

로그인 및 반복 조회 시 매번 DB 접근이 이루어져 응답 지연이 발생했습니다. Redis를 도입하여 세션, 토큰, TTL 기반 캐싱을 적용함으로써 데이터베이스 부하를 줄였습니다. Memcached, Caffeine, Hazelcast를 검토했으나 Redis가 TTL 관리와 세션 유지, 블랙리스트 관리에 가장 적합했습니다.

Redis 캐싱 적용 후 로그인 요청 응답 시간은 평균 ???ms에서 ???ms로 단축, DB 쿼리 부하는 ???% 감소했습니다.

---

## 6. 사용자 인증 및 인가 구조

JWT 기반의 무상태 인증 구조를 도입하고 Spring Security로 인증·인가 체계를 통합했습니다. 세션이나 쿠키 기반 인증 대비 확장성이 높고, Redis를 이용한 토큰 블랙리스트 관리가 가능했습니다. Apache Shiro, pac4j, Keycloak 등을 검토했으나 Spring Security가 스프링 부트와의 통합성과 유지보수성 면에서 가장 적합했습니다.

JWT와 Redis 결합을 통해 세션 동기화 문제를 제거하고, 인증 요청 처리 속도는 평균 ???ms 개선되었습니다.

---

## 7. 플레이리스트 관리 모듈

사용자별 재생목록 관리 기능을 JPA, QueryDSL 기반으로 설계했습니다. Playlist 엔티티를 중심으로 PlaylistVideo 조인 엔티티를 통해 다대다 관계를 정규화했습니다. QueryDSL을 활용해 복합 조건 쿼리를 타입 안정적으로 처리하고, JPA를 통한 트랜잭션 일관성을 확보했습니다.

YouTube API와 연동된 VideoService로 메타데이터를 자동 조회·저장하도록 구성했으며, 조회 속도는 기존 대비 ???% 향상되었습니다.

---

## 8. ChatGPT Open API

ChatGPT OpenAI API, Claude API, Gemini API를 비교 검토한 결과 안정성과 응답 품질이 가장 우수한 ChatGPT OpenAI API를 도입했습니다. LangChain, LlamaIndex, 직접 구현 방식을 비교한 프롬프트 오케스트레이션에서는 초기 유지보수 부담을 고려해 직접 구현을 선택했습니다.

서비스 계층에서는 요청 생성, 인증 헤더 설정, 응답 파싱, 예외 처리 과정을 하나의 트랜잭션으로 통합했습니다. Jackson을 활용해 메시지를 직렬화하고, JPA를 통해 사용자별 프롬프트와 응답을 Gpt 엔티티에 저장했습니다. QueryDSL로 조회 효율을 높여 사용자 대화 데이터의 지속 관리와 개인화 서비스 확장 기반을 마련했습니다.

현재 ChatGPT API를 활용해 사용자 질의응답, 글 요약, 태그 추천 기능을 실서비스에 적용 중이며, 향후 Whisper API를 연계해 음성 입력 기반 Q&A 기능으로 확장할 계획입니다. 응답 속도는 평균 ???ms, 처리 성공률은 ???%를 기록했습니다.





