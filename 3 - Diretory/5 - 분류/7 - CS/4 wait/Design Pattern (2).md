

----
##### 연결 문서

- 
- 
- 
---

##### 제목 : 

-  DTO / DAO / VO
        
        ```java
        - DTO : Data Transfer Object 
        	계층간 데이터를 교환하기 위한 객체(Java Bean)이다.
        	* DTO는 로직을 가지지 않는 순수한 객체(getter & setter만 가진)이다.
        
        	* DTO는 순수하게 데이터를 저장하고 데이터에 대한 getter, setter만 가져야한다.
        		어떠한 비지니스 로직도 가져서는 안되며 
        		저장, 검색, 직렬화, 역직렬화 로직만 가져야 한다.
        
        	* 유저가 입력한 데이터를 DB에 넣는 과정의 예시
        		1) 유저가 자신의 브라우저에 데이터를 입력하여 from에 있는 데이터를 DTO에
        			 넣어서 전송한다.
        		2) 해당 DTO를 받은 서버가 DAO를 이용하여 데이터베이스로 데이터를 집어넣는다.
        
        - DAO : Data Acess Object
        	데이터베이스의 data에 접근하기 위한 객체이다.
        	Database에 접근하기 위한 로직 & 비지니스 로직을 분리하기 위해 사용한다.
        
        - VO : Value Object 
        	* 값 오브젝트로써 사용하기 위해 쓰인다.
        	* read-Only 특징(사용하는 도중에 변경이 불가능하며 오직 읽기만 가능)을 가진다.
        	* DTO와 유사하지만 DTO는 setter를 가지고 있어 값이 변할 수 있다.
        ```
        
        ![MVC 패턴.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/11b23e09-5eeb-440a-86c3-5fb272d32444/1c25293c-a494-4dc5-901a-06d04924e722/MVC_%ED%8C%A8%ED%84%B4.png)
    
- 디자인 패턴
    
    ```java
    - 디자인 패턴이란? : 
    	"소프트웨어 개발 방법"으로 사용되는 디자인패턴은 
    	과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 
    	그 방법에 이름을 붙여서 이후에 재사용하기 좋은 형태로 특정 규약을 만들어서 정리한 것이다. 
    
    	디자인 패턴은 소프트웨어 설계에 있어 공통적인 문제들에 대한	표준적인 해법과 작명법을 제안하며, 
    	알고리즘과 같이 프로그램	코드로 바로 변환될 수 있는 형태는 아니지만, 
    	특정한 상황에서 구조적인 문제를 해결하는 방식이다. 
    	즉 "효율적인 코드를 만들기 위한 방법론"이라고 생각하면 된다.
    
    - 올바른 관계를 맺어야하는 이유 : 
    	* 클래스는 최소한의 단위 기능을 가짐.
    	* 큰 기능은 이러한 단위 기능을 갖는 클래스들 간의 관계를 통해 개발됨.
    	* 꼭 필요한 것들만으로 구성된 최적화된 소프트웨어 개발에 용이함.
    	* 문제 발생시 최소한의 코드 수정으로 유지보수가 용이함.
    	* 기존 기능에 영향을 주지 않고 새로운 기능 추가가 용이함.
    
    - Gof의 디자인 패턴 : 
    	* "가장 유용하며 대표적인 디자인 패턴"
    	* 4명의 선배 개발자들(Gang of Four)가 체계적으로 정리해 놓은 설계 방법
    	* 총 23개의 패턴으로 구성되며 생성 패턴(5개), 구조 패턴(7개), 행위 패턴(11개)로 분류.
    
    1. 생성 패턴 : 
    	 객체 생성에 관련된 패턴이다. 객체의 생성과 조합을 캡슐화해
    	 특정 객체가 생성되거나 변경되어도 프로그램 구조에 크게 영향을 받지 않도록 유연성을 제공한다. 
       [ 단!, 디자인 패턴은 객체지향 프로그래밍에 많이 다루지만 오직 객체 생성과 
    		관련된 것이 아니다. 다양한 소프트웨어 디자인 측면에 대한 일반적인 문제를 해결하기 
    		위한 일반적인 지침을 제공한다는 것을 명심하자.]
    	* 생성 패턴은 인스턴스를 만드는 절차를 추상화하는 패턴이다.
     	  생성 패턴에 속하는 패턴들은 객체를 생성, 합성하는 방법이나 객체의 표현 방법을 
    		시스템과 분리해준다. 
    		생선 패턴은 시스템이 상속보다 복합 방법을 사용하는 방향으로 진화되어 가면서 
    		더 중요해지고 있다. 
    	* 생성 패턴의 중요한 이슈 2가지 : 
    		1) 생성 패턴은 시스템이 어떤 Concrete Class를 사용하는지에 대한 정보를 캡슐화한다.
    		2) 생성 패턴은 이들 클래스의 인스턴스들이 어떻게 만들고 어떻게 결합하는지에 
    			 대한 부분을 완전히 가려준다.
    			 쉬운 말로 정리하자면, 생성패턴을 이용하면 무엇이 생성되고, 
    			 누가 이것을 생성하며 이것이 어떻게 생성되는지, 
    			 언제 생성할 것 인지 결정하는 데 유연성을 확보할 수 있게 된다.
    	
    2. 구조 패턴 : 
    	 구조패턴은 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴이다.
    	 예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나
    	 객체들은 서로 묶어 새로운 기능을 제공하는 패턴이다. 
    	* 어댑터 패턴 : 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록, 
    		타 클래스의 인터페이스를 기존 인터페이스에 덧씌운다. 
    	* 브리지 패턴 : 추상화와 구현을 분리해 둘을 각각 따로 발전시킬 수 있다. 
    	* 합성 패턴 : 0개, 1개 혹은 그 이상의 객체를 묶어 하나의 객체로	이용할 수 있다.
    	* 데코레이터 패턴 : 기존 객체의 메서드에 새로운 행동을 추가하거나 오버라이드 
    		할 수 있다. 
    	* 퍼사드 패턴 : 많은 분량의 코드에 접근할 수 있는 단순한 인터페이스를 제공한다.
    	* 플록시 패턴 : 접근 조절, 비용 절감, 복잡도 감소를 위해 접근이	힘든 객체에 대한 
    		대역을 제공한다.
    
    3. 행동 패턴 : 
    	 행동 패턴은 객체의 상호작용과 책임 분산에 초점을 둔 디자인 패턴이다. 
    	 시스템 설계 시 행동 패턴을 적용하면 복잡한 객체 간 통신을 간소화하고, 
    	 각 객체의 독립성을 유지할 수 있다. 
    	 또한 객체를 독립적으로 다룰 수 있게 되어 테스트를 편리하게 진행할 수 있으며, 
    	 코드의 재사용성도 높일 수 있다.
    	
    4. 디자인패턴에 대한 비판 : 
    	* 복잡성 : 디자인 패턴은 프로그램의 복잡성을 증가시킬 수 있다. 
    		패턴은 일반적으로 다른 클래스가 객체와의 상호작용을 추가하므로 클래스 간의 
    		관계가 더 복잡해질 수 있다.
    	* 오용 : 디자인 패턴을 많이 사용되면 개발자들은 간단한 문제를 오히려 복잡하게 
    		해결할려고 시도하는 꼴이 된다. 
    		이는 프로그램의 효율성을 저하시키고 유지 보수를 어렵게 만들 수 있다.			
    	* 부적절한 적용 : 디자인 패턴을 잘못 적용하면 문제를 더 복잡하게 만들 수 있다.
    		각 패턴은 문제 해결을 위해 고안되었으므로, 그 패턴을 해결하려는 문제와 일치하지 않는
    		다른 문제에 적용하면, 예상치 못한 결과가 발생할 수 있다.
    
    5. 디자인 패턴 종류 : 
    	* 생성 패턴 : 
    		- Singleton, Abstract Factory, Factory Method, Builder, Prototype
    	* 구조 패턴 : 
    		- Adepter, Composite, Decorator, Facade, Flyweight, Proxy
    	* 행동 패턴 : 
    		- Command, Interpreter, Iterator, Madiator, Memento, Strategy 등..
    ```



- 팩토리 메서드 패턴
    
    ```java
    - 팩토리 메서드 패턴 | Factory Method : 
    	부모 클래스에서 객체들을 생성할 수 있는 인터페이스를 제공하지만, 
    	자식클래스들이 생성될 객체들의 유형을 변경할 수 있도록 하는 생성 패턴이다.
    
    - 어떠한 경우 사용하는가? : 
    	물류 관리 앱을 개발하고 있다고 가정해보자.
    	앱의 첫 번째 버전은 트럭 운송만 처리할 수 있어서 대부분의 코드가 Truck(트럭) 클래스에 있다.
    	또 얼마 후 개발 중인 앱이 유명해져서, 매일 해상 물류 회사들로부터 
    	해상 물류 기능을 앱에 추가해달라는 요청을 수십개 씩 받았다고 가정한다.
    	나머지 코드가 이미 기존 클래스에 결합되어있다면 프로그램에 새 클래스를 추가하는 일은 그리 간단하지 않다.
    	
    	좋은 소식이지만, 현재 대부분의 코드는 Truck(트럭) 클래스에 결합되어 있다. 
    	앱에 Ship(선박) 클래스를 추가하려면 전체 코드 베이스를 바꿔야한다. 
    	또한 차후 앱에 다른 유형의 교통 수단을 추가하려면 아마도 다시 전체 코드 베이스를 변경해야 할 것이다.
    
    	그러면 결과적으로 많은 조건문이 운송 수단 객체들의 클래스에 따라 
    	앱의 행동을 바꾸는 매우 복잡한 코드가 작성될 것이다.
    	즉, 앱의 유지보수와 재사용성이 매우 떨어지게 되는 것이다.
    
    - 해결책 : 
    	팩토리 메서드 패턴은 (new 연산자를 사용한) 객체 생성 직접 호출들을 특별한 "팩토리" 메서드에 대한 
    	호출들로 대체하라고 제안한다. 
    	객체들은 여전히 new 연산자를 통해 생성되지만 팩토리 메서드 내에서 호출되고 있다.
    	참고로 팩토리 메서드에서 반환된 객체는 종종 "제품"이라고 부른다.
    	(자식 클래스들은 팩토리 메서드가 반환하는 객체들의 클래스를 변경할 수 있다. 
    
    	얼핏 이러한 변경은 무의미해보일 수도 있는데, 
    	그 이유는 생성자 호출을 프로그램의 한부분에서 다른 부분으로 옮겼을 뿐이기 때문이다.
    	그러나 위와 같은 변경 덕분에 이제 자식 클래스에서 팩토리 메서드를 오버라이딩하고 
    	그 메서드에 의해 생성되는 제품들의 클래스를 변경할 수 있게 되었다.
    	
    	하지만 약간의 제한이 존재한다.
    	자식 클래스들은 다른 유형의 제품들을 해당 제품들이 공통 기초 클래스 
    	또는 공통 인터페이스가 있는 경우에만 반환할 수 있다.
    	또 이전에 언급한 모든 제품들에 공통인 Transport 인터페이스로 losistics 기초 클래스의 
    	createTransport 팩토리 메서드의 반환 유형을 선언해야 한다.
    	(모든 제품들은 같은 인터페이스를 따라 가야한다.) 
    	
    	예를 들어 Truck과 Ship 클래스들은 모두 Transport 인터페이스를 구현해야 하며,
    	이 인터페이스는 deliver(배달)라는 메서드를 선언한다.
    	그러나 각 클래스는 이 메서드를 다르게 구현해야한다.
    	트럭은 육로로 배달하고 선박은 해상으로 배달한다. 
    	RoadLogistics(도로 물류) 클래스에 포함된 팩토리 메서드는 Truck 객체들을 반환하는 반면, 
    	SeaLogistics(해상 물류) 클래스에 포함된 팩토리 메서드는 선박 객체들을 반환한다.
    	(모든 제품 클래스들이 공통 인터페이스를 구현하는 한, 제품 클래스들의 객체들을 손상하지 않고 
    	클라이언트 코드를 통과시킬 수 있다.)
    
    - 클라이언트 코드 : 
    	팩토리 메서드를 사용하는 코드를 종종 "클라이언트 코드"라고 부른다.
    	클라이언트 코드는 다양한 자식 클래스들에서 실제로 반환되는 여러 제품 간의 차이에 대해 알지 못한다. 
    	클라이언트 코드는 모든 제품을 추상Transport(운송체계)로 간주한다.
    	클라이언트는 모든 Transport 객체들이 deliver(배달) 메서드를 가져야 한다는 사실을 잘 알고 있지만, 
    	이 메서드가 정확히 어떻게 작동하는지는 클라이언트에게 중요하지 않다.
    	
    - 구조 : 
    	1. 제품은 인터페이스를 선언 : 
    		 인터페이스는 생성자와 자식 클래스들이 생성할 수 있는 모든 객체들의 공통이다.
    	2. 구상 제품들은 제품 인터페이스의 다양한 구현들이다.
    	3. 크리에이터(Creator) 클래스는 새로운 제품 객체들을 반환하는 팩토리 메서드를 선언한다.
    	   중요한점은 이 팩토리 메서드의 반환 유형이 제품 인터페이스와 일치해야 한다는 것이다.
    		 팩토리 메서드를 abstract(추상)으로 선언하여 모든 자식 클래스들이, 
    		 각각 이 메서드의 자체 버전들을 구현하도록 강제할 수 있으며, 또 대안적으로 기초 팩토리 메서드가
    		 디폴트(기본값) 제품 유형을 반환하도록 만들 수도 있다.
    		& 주의사항 : 
    			크리에이터라는 이름에도 불구하고, 크리에이터의 주책임은 제품의 "생성"이 아니다. 
    			일반적으로 크리에이터 클래스에는 이미 제품과 관련된 핵심 비지니스 로직이 있으며, 
    			팩토리 메서드는 이 로직을 구상하는 제품 클래스로부터 디커플링(분리) 하는데 도움을 줄 뿐이다.
    		  소프트웨어 회사로 예시를 들자면 프로그래머들을 위한 교육 부서는 있을 수 있으나 
    			회사의 주 임무는 프로그래머 교육이 아닌 "코딩의 작성"이다.
    ```
    
    ![디자인 패턴 - 팩토리 메서드 - 크로스 플랫폼 다이얼로그.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/11b23e09-5eeb-440a-86c3-5fb272d32444/2b175f6a-1dc9-43e4-8dfb-cbd4e9a179fa/%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4_-_%ED%8C%A9%ED%86%A0%EB%A6%AC_%EB%A9%94%EC%84%9C%EB%93%9C_-_%ED%81%AC%EB%A1%9C%EC%8A%A4_%ED%94%8C%EB%9E%AB%ED%8F%BC_%EB%8B%A4%EC%9D%B4%EC%96%BC%EB%A1%9C%EA%B7%B8.png)
    
    - 출처 : [https://refactoring.guru/ko/design-patterns/factory-method](https://refactoring.guru/ko/design-patterns/factory-method)
- 추상 팩토리 패턴
    
    ```java
    - 추상팩토리 패턴 | Abstract Favctory : 
    	"관련 객체들의 구상 클래스들을 지정하지 않고도 관련 객체들의 모음을 생성할 수 있도록 하는 생성 패턴"
    
    	팩토리 메소드 패턴에서는 하나의 팩토리 클래스가 인풋으로 들어오는 값에 따라 
    	if-else나 switch 문을 사용하여 다양한 서브클래스를 리턴하는 형식으로 구현했다.
    	추상 팩토리 패턴에서는 팩토리 클래스에서 서브 클래스를 생성하는 데에 있어 
    	if-else 문을 걷어낸다. 
    	추상팩토리 패턴은 인풋으로 서브클래스에 대한 식별 데이터를 받는 것이 아니라 
    	또 하나의 팩토리 클래스를 받는다. 
    
    - 추상 팩토리 패턴의 장점 : 
    	추상 팩토리 패턴은 구현(Implements)보다 인터페이스(Interface)를 위한 코드 접근법을 
    	제공한다. 
    
    - 추상 팩토라 패턴은 추후에 sub class를 확장하는 데 있어 굉장히	쉽게할 수 있다. 
    
    - 추상 팩토리 패턴은 팩토리 패턴(팩토리 메소드 패턴)의 
    	조건문(if-else, switch 등)으로부터 벗어난다.
    
    - 추상 팩토리 vs 팩토리 메서드 차이점 : 
    	* 추상 팩토리 : 서로 관련이 있는 객체들을 통째로 묶어서 팩토리 클래스로 만들고, 
    		이들 팩토리를 조건에 따라 생성하도록	다시 팩토리를 만들어서 객체를 생성하는 패턴 
    	* 팩토리 메서드 패턴 : 조건에 따른 객체 생성을 팩토리 클래스로 위임하여, 
    		팩토리 클래스에서 객체를 생성하는 패턴
    	* 추상 팩토리 패턴은 어떻게 보면, 팩토리 메서드 패턴을 좀 더 캡슐화한 방식이라고 
    		볼 수 있다.
    
    - 출처 : 
    	<https://readystory.tistory.com/119>
    	추상 팩토리에 대한 설명이 잘되어 있다. 
    	예제 코드를 보며 이해하는 것이 좋을 것 같다.
    ```
    
- 빌더 패턴
    
    ```java
    - 빌더 패턴 | Builder : 
    	복잡한 객체의 생성 과정과 표현 방법을 분리하여 다양한 구성의
    	인스턴스를 만드는 생성 패턴이다, 
    	생성자에 들어갈 매개 변수를 메서드로 하나하나 받아들이고 
    	마지막에 통합 빌드해서 객체를 생성한 방식이다.
    
    - 예시 : 수제 햄버거를 예시로 들어보자 
    	수제 햄버거를 주문할때 빵이나 패티 등 속재료들은 주문하는 사람이
    	마음대로 결정된다. 어느 사람은 치즈를 빼달라고 할 수 있고 어느
    	사람은 토마토를 빼달라고 할수 있다. 이처럼 선택적 속재료를 
    	보다 유연하게 받아 다양한 타입의 인스턴스를 생성할수 있어, 
    	클래스의 선택적 매개변수가 많은 상황에서 유용하게 적용되는 디자인 패턴이다.
    
    - 빌더 패턴의 장점 
    	1) 객체 생성 과정을 일관된 프로세스로 표현 :
    		 생성자 방식으로 객체를 생성하는 경우는 매개변수가 많아질수록 가독성이 급격하게 떨어진다. 
    		 클래스 변수가 4개 이상만 되어도 각 인자 순서 마다 이 값이 어떤 멤버에 해당되는지 바로 파악이 힘들다. 
    		 반면 다음과 같이 빌더 패턴을 적용하면 직관적으로 어떤 데이터에 어떤 값이 설정되는지 한눈에 파악할 수 있게 된다.
    		 특히 연속된 동일 타입의 매개 변수를 많이 설정할 경우에 발생할 수 있는 설정 오류와 같은 실수를 방지할 수 있다.
    	2) 디폴트 매개변수 생략을 간접적으로 지원 : 
    		 본래 디폴트 매개변수라는 건 인자 값을 설정해줘도 설정 안하고 생략해도 되는 것을 말한다. 
    		 그런데 파이썬이나 자바스크립트와 달리 자바 언어에선 기본적으로 메서드에 대한 디폴트 매개변수를 지원하지 않는다. 
    		 따라서 디폴트 매개변수를 구현하기 위해선 클래스 필드 변수에 초깃값으로 미리 셋팅하고, 
    		 초기값이 세팅된 필드 인자를 제외시킨 생성자를 따로 구현하는 식으로 설계해야한다. 
    		 하지만 이는 결국 지나친 생성자 오버로딩 열거를 통한 본래의 문제점을 회귀한 꼴이 된다. 
    		 빌더 패턴에서도 디폴트 매개 변수를 구현하는 방법은 똑같다. 
    		 다만 빌더라는 객체 생성 전용 클래스를 경유하여 이용함으로써 디폴트 매개변수가 설정된 
    		 필드를 설정하는 메서드를 호출하지 않는 방식으로 
    		 마치 디폴트 매개변수를 생략하고 호출하는 효과를 간접적으로 구현할 수 있게 된다. 
    	3) 필수 멤버와 선택적 멤버를 분리 가능
    		 객체 인스턴스는 목적에 따라 초기화가 필수인 멤버 변수가 있고
    		 선택적인 멤버 변수가 있을 수 있다. 
    		 빌드 클래스를 통해 초기화가 필수인 멤버는 빌더의 생성자로 받게 하여 
    		 필수 멤버를 설정해주어야 빌더 객체가 생성되도록 유도하고, 
    		 선택적인 멤버는 빌더의 메서드로 받도록 하면, 
    		 사용자로 하여금 필수 멤버와 선택 멤버를 구분하여 객체 생성을 유도할 수 있다.
    	4) 객체 생성 단계를 지연할 수 있음
    		 객체 생성을 단계별로 구성하거나 구성 단계를 지연하거나 
    		 재귀적으로 생성을 처리 할 수 있다. 
    		 즉, 빌더를 재사용 함으로써 객체 생성을 주도적으로 지연할 수 있는 것이다. 
    	5) 초기화 검증을 멤버별로 분리 
    		 만일 생성자로 부터 멤버값을 받는 형태라면, 
    		 각 생성자 매개변수에 대한 검증 로직을 생성자 메소드 마다 복잡하게 구현하여야 한다. 
    		 이는 생성자의 크기가 비대해지게 되는 결과를 낳게 된다.
    
    - 빌더 패턴의 단점 : 
    	1) 코드 복잡성 증가 : 
    		 어느 디자인 패턴이든 가지는 단점이지만, 
    		 빌더 패턴을 적용하려면 N개의 클래스에 대해 N개의 새로운 빌더 클래스를 만들어야 해서,
    		 클래스 수가 기하급수적으로 늘어나 관리해야 할 클래스가 많아지고 
    		 구조가 복잡해질 수 있다. 
    		 또한 선택적 매개변수를 많이 받는 객체를 생성하기 위해서는 먼저 빌더 클래스부터 
    		 정의해야한다.
    	2) 생성자 보다는 성능이 떨어진다. 
    		 매번 메서드를 호출하여 빌더를 거쳐 인스턴스화 하기 때문에 
    		 어쩌면 당연한 말일지도 모른다. 
    		 어플리케이션 성능을 극으로 중요시되는 상황이라면 문제가 될 수 있다.
    	3) 지나친 빌더 남용은 금지 
    		 클래스의 필드의 개수가 4개 보다 적고, 필드의 변경 가능성이 없는 경우라면 
    		 차라리 생성자나 정적 팩토리 메서드를 이용하는 것이 좋을 수도 있다.
    		 
    - 참고 출처 : 
    <https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EB%B9%8C%EB%8D%94Builder-%ED%8C%A8%ED%84%B4-%EB%81%9D%ED%8C%90%EC%99%95-%EC%A0%95%EB%A6%AC>
    ```
    
- 프로토타입 패턴
    
    ```java
    - 프토토타입 패턴 | Prototype : 
    	프로토타입은 실제 제품을 만들기에 앞서 테스트를 위한 샘플 제품을
    	만드는데 이때, 샘플 제품을 프로토타입이라고 칭한다. 
    	프로토타입 패턴은 객체를 생성하는데 비용이 많이 들고, 
    	비슷한 객체가 이미 있는 경우에 사용되는 생선 패턴 중 하나이다. 
    	즉, 프로토타입 패턴은 원본 객체를 새로운 객체에 복사하여 필요에	따라 
    	수정하는 메커니즘을 제공한다. 
    	프로토타입은 복사를 위해 자바에서 제공하는 'clone'메소드를 사용
    
    - 프로토타입은 생성패턴이다. : 
    	생성패턴은 인스턴스를 만드는 절차를 추상화하는 패턴이다. 
    	생성패턴에 속하는 패턴들은 객체를 생성, 
    	합성하는 방법이나 객체의 표현방법을 시스템과 분리해준다. 
    	생성패턴은 시스템이 상속보다 복합방법을 사용하는 방향으로 진화하면서 
    	더욱 중요해지고 있다. 
    
    - 생성패턴에는 두 가지의 이슈가 존재한다. 
    	1) 생성 패턴은 시스템이 어떤 Concrete Class를 사용하는지에 대한 정보를 캡슐화한다. 
    	2) 생성 패턴은 이들 클래스의 인스턴스들이 어떻게 만들고 어떻게 결합하는지에 
    		 대한 부분을 완전히 가려준다.
    
    - 프로토타입 패턴 구현 : 
    	위에서 정의했듯이, 프로토타입 패턴은 객체를 생성하는데 비용이 들고, 
    	이미 유사한 객체가 존재하는 경우에 사용된다. 
    	자바에서 제공하는 clone메소드를 사용하기 때문에 생성하고자 하는 객체에 
    	clone에 대한 Override를 요구한다. 
    	이때, 주의할 점은 반드시 생성하고자 하는 객체의 클래스에서 
    	clone메소드가 정의되어 있어야한다. 
    	예를 들어, DB로부터 가져온 데이터를 프로그램에서 수차례 수정을 해야하는 
    	요구사항이 있는 경우 매번 new 키워드를 사용해 
    	객체를 생성하여 DB로부터 모든 데이터를 가져오는 것은 좋은	아이디어가 아니다. 
    	그 이유는 DB로 접근해서 데이터를 가져오는 행위는 비용이 크기 때문이다. 
    	따라서 한번 DB에 접근하여 데이터를 가져온 객체를 필요에 따라 
    	새로운 객체에 복사하여 데이터 수정작업을 하는것이 더 좋은 방법이다.
    
    - 프로토타입 패턴은, 추상 팩토리 패턴과 클라이언트 응용 프로그램 코드 내에서 
    	객체 창조자(creator)를 서브클래스하는 것을 피 할 수 있게 해준다.
    
    - 프로토타입 패턴은 새로운 객체는 일반적인 방법(예를 들어 new를	사용해서라든지)으로 
    	객체를 생성(create)하고 있는 고유의 비용이	주어진 응용 프로그램 상황에 있어서 
    	불가피하게 매우 클 때, 이 비용을 감내하지 않을 수 있게 해준다.	
    
    출처 : 
    <https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%ED%8C%A8%ED%84%B4>
    ```
    
- 싱글톤 패턴
    
    ```java
    - 싱글톤 패턴 | Singleton : 
    	"객체의 인스턴스가 오직 1개만 생성되는 패턴"
    	소프트웨어 디자인 패턴에서 싱글턴 패턴을 따르는 클래스는, 
    	생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고
    	최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 
    	리턴한다. 이와 같은 디자인 유형을 싱글톤 패턴이라고 한다. 
    	주로 공통된 객체를 여러개 생성해서 사용하는
    	DBCP(Database Connection Poll)와 같은 상황에서 많이 사용된다.
    
    - 싱글톤은 클래스에 인스턴스가 하나만 있도록 하면서 이 인스턴스에
    	대한 전역 접근(엑세스)지점을 제공하는 생성 디자인 패턴이다.
    
    - 싱글톤 패턴의 문제점 : 
    	1) 클래스에 인스턴스가 하나만 있도록 해야한다. 
    	 	 클래스에 있는 인스턴스 수를 제어하려는 가장 일반적인 이유는
    	 	 일부 공유 리소스(예:데이터베이스 또는 파일)에 대한 접근을
    		 제어하기 위함이다. 
    	2) 해당 인스턴스에 대한 전역 접근 지점을 제공한다. : 
    		 필수 객체들은 저장하기 위해 전역 변수들은 정의했다고 
    		 가정할 때, 이 변수들은 사용하면 매우 편리할지는 몰라도, 
    		 모든 코드가 잠재적으로 해당 변수의 내용을 덮어쓸 수 있고
    		 그로 인해 앱에 오류가 발생해 충돌할 수 있으므로 그리 안전한
    		 방법은 아니다. 
    
    - 해결책 : 
    	1) 다른 객체들이 싱글톤 클래스와 함께 new 연산자를 사용하지 못하도록 디폴트 생성자를 
    		 비공개로 설정해야한다.
    	2) 생성자 역할을 하는 정적 생성 메서드를 만들어야 한다.
    		 이 메서드는 객체를 만들기 위하여 비공개 생성자를 호출한 후 객체를 정적 필드에 
    		 저장한다. 
    		 이 메서드에 대한 그 다음 호출들은 모두 캐시된 객체를 반환한다. 
    
    - 실제사례 : 
    	정부 : 싱글톤 패턴의 훌륭한 예시이다. 국가는 하나의 공식 정부만 가질 수 있다. 
    				 그리고 'X의 정부'라는 명칭은 정부를 구성하는 개인들의 신원과 관계없이 
    				 정부 책임자들의 그룹을 식별하는 글로벌 접근 지점이다. 
    
    - 출처 : 
    	<https://refactoring.guru/ko/design-patterns/singleton>
    ```
    
- 어댑터 패턴
    
    ```java
    - Adapter : 구조 패턴
    	이름대로 어댑터처럼 사용되는 패턴이다.
    	220V를 사용하는 한국에서 쓰던 기기들을, 어댑터를 사용하면
    	110V를 쓰는곳에 가서도 그대로 쓸 수 있다.
    	호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이
    	함께 작동하도록 해주는 패턴이 어댑터 패턴이다. 이를 위해 
    	어댑터 역할을 하는 클래스를 새로 만들어야 한다. 
    	기존에 있는 시스템에 새로운 써드파티 라이브러리가 추가된다던지, 
    	레거시 인터페이스를 새로운 인터페이스로 교체하는 경우에 코드의
    	재사용성을 높일 수 있는 방법이 어댑터 패턴을 사용하는 것이다.
    
    - 어탭터 패턴 장점 : 
    	1) 관계가 없는 인터페이스 간 같이 가능
    	2) 프로그램 검사 용이
    	3) 클래스 재활용성 증가
    
    - 출처 : 
    <https://velog.io/@ha0kim/Design-Pattern-%EA%B5%AC%EC%A1%B0-%ED%8C%A8%ED%84%B4Structural-Patterns>
    ```
    
- 브릿지 패턴
    
    ```java
    - Bridge Pattern : 구조 패턴
    	구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 
    	하는 패턴이다. 즉, 추상적 개념과 구체적 구현을 서로 다른
    	두개의 인터페이스로 구현하는 디자인 패턴이다.
    	브릿지 패턴은 캡슐화, 집합을 사용하고 또한 다른 클래스들로 
    	책임을 분리시키기 위해 상속을 사용할 수 있다. 
    - 브릿지 패턴 장점 : 
    	1) 인터페이스와 구현이 분리된다.
    	2) 서로 독립적으로 확장할 수 있다.
    	3) 구현 세부사항을 클라이언트에게 은닉하여 캡슐화를 지킬 수 있다
    
    - 출처 : 
    <https://velog.io/@ha0kim/Design-Pattern-%EA%B5%AC%EC%A1%B0-%ED%8C%A8%ED%84%B4Structural-Patterns>
    ```
    
- 프록시 패턴
    
    ```java
    - Proxy : 구조 패턴
    	실제 기능을 수행하는 객체 대신 가상의 객체(Proxy Object)를 사용해 
    	로직의 흐름을 제어하는 디자인 패턴이다. 
    	프록시 패턴을 사용하는 경우는 처리 할 수 있는 부분은 처리를 하고
    	proxy 클래스에서 처리할 수 없는 작업에 대해서만 실제 클래스의 객체를 생성하고 
    	위임하는 방식을 취한다. 
    
    - 프록시 패턴 특징 : 
    	1) 원래 하려던 기능을 수행하며 그외의 부가적인 작업(로깅, 인증, 네트워크 통신 등)을 
    		 수행할 수 있다. 
    	2) 비용이 많이 드는 연산(DB 쿼리, 대용량 텍스트 파일 등)을 실제로 
    		 필요한 시점에 수행할 수 있다.
    	3) 실제 객체의 리소스가 무거운 경우, 프록시 객체에서 간단한 처리를 하거나 
    		 기본 객체를 캐싱 처리함으로써 부하를 줄일 수 있다. 
    	4) 실제 객체에 대한 수정 없이 클라이언트에서의 사용과 기본 객체 사이에 
    		 일련의 로직을 프록시 객체를 통해 넣을 수 있다.
    	5) 프록시 기본 객체와 요청 사이에 있기 때문에 일종의 방패(보안)의 역할도 한다.
    	6) 사용자 입장에서는 프록시 객체나 실제 객체나 사용법이 유사하므로 
    		 구조나 코드 구현이 간단하다.
    
    - 프록시 패턴 종류 : 
    1. 원격 프록시 : 원격 객체에 대한 접근 제어가 가능하다.
    2. 가상 프록시 : 객체의 생성비용이 많이 들어 미리 생성하기 힘든 객체에 대한 
    	 접근 및 생성시점 등을 제어한다.
    3. 보호 프록시 : 객체에 따른 접근 권한을 제어해야하는 객체에 대한 접근을 제어한다.
    4. 방화벽 프록시 : 일련의 네트워크 자원에 대한 접근을 제어함으로써 
    	 주 객체를 '나쁜'클라이언트로부터 보호한다.
    
    - 출처 : 
    <https://velog.io/@ha0kim/Design-Pattern-%EA%B5%AC%EC%A1%B0-%ED%8C%A8%ED%84%B4Structural-Patterns>
    ```
    
- 전략 패턴
    
    ```java
    - Strategy : 행동 패턴
    	객체들이 할 수 있는 헹위 각각에 대해 전략 클래스를 생성하고, 
    	유사한 행위들을 캡슐화 하는 인터페이스를 정의하여, 
    	객체의 행위를 동적으로 바꾸고 싶은 경우 직접 행위를 수정하지
    	않고 전략을 바꿔주기만 하믕로써 행위를 유연하게 확장하는 방법을
    	말한다. 간단히 말해서 객체가 할 수 있는 행위를 각각을 전략으로
    	만들어 놓고, 동적으로 행위의 수정이 필요한 경우 전략을 바꾸는
    	것만으로 행위의 수정이 가능하도록 만든 패턴이다.
    
    - 전략 패턴은 실행 중에 알고리즘을 선택할 수 있게 하는 행위 
    	* 특정한 계열의 알고리즘들을 정의하고
    	* 각 알고리즘을 캡슐화하며
    	* 이 알고리즘을 해당 계열 안에서 상호 교체가 가능하게 만든다.
    
    - 전략은 알고리즘을 사용하는 클라이언트와 독립적으로 다양하게 만든다. 
    	전략은 유연하고 재사용 가능한 객체 지향 프로그래밍을 어떻게 설계하는지 
    	기술하기 위해 디자인 패턴의 개념을 보급시킨 디자인패턴이라는 
    	영향력 있는 책에 포함된 패턴들 가운데 하나이다.
    
    - 출처 : 
    <https://ko.wikipedia.org/wiki/%EC%A0%84%EB%9E%B5_%ED%8C%A8%ED%84%B4>
    ```
    
- 메멘토 패턴
    
    ```java
    - Memento : 행동 패턴
    	메멘토 패턴은 객체를 이전 상태로 되돌릴 수 있는 기능을 제공하는 소프트웨어 
    	디자인 패턴이다. 
    	메멘토 패턴은 3개의 객체로 구현된다. 
    	오리지네이터, 케어테이커, 메멘토. 오리지네이터는 내부 상태를 보유하고 있는 
    	일부 객체이다. 
    	케이테이커는 오리지네이터에 대해 무언가를 하지만 변경에 대한 실행 취소를 하기를 원한다. 
    	케어테이커는 먼저 오리지네이터에게 메멘토 객체를 요청한다.
    	그 뒤 예정된 일련의 명령을 수행한다. 
    	명령 이전의 상태로 되돌리기 위해 메멘토 객체를 오리지네이터에 반환한다. 
    	메멘토 객체 자신은 불투명 자료형(케이테이커는 변경할 수 없거나 변경해서는 안되는)이다.
    
    - 출처 : 
    <https://ko.wikipedia.org/wiki/%EB%A9%94%EB%A9%98%ED%86%A0_%ED%8C%A8%ED%84%B4>
    ```
    
