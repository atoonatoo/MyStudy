
---
### ChatGPT 호출량 제한
- gpt api는 소정의 금액을 충전하여 이용자가 질문 횟수에 따라 (호출 1회 = 0.03원) 비용이 소비된다. 
- 따라서 많은 요청으로 인한 한정된 비용을 절약하고, 악의적 의도를 가진 사용자에 대한 호출 방지가 필요하다.

- version 1.1 : GPT 호출량 제한
	- 구현 방식
		- `Redis`를 활용하여 사용자별 호출 횟수를 기록한다.
		- Redis의 `INCR`, `EXPIRE` 명령을 활용해 하루 단위로 자동 초기화 되도록 구성한다.
	- 문제점
		- 호출량을 제한하여 비용은 절감할 수 있지만, UX가 감소하여 이용자는 굳이 내가 만든 홈페이지를 이용할 메리트가 없어지며, 공식 홈페이지의 GPT를 이용하는게 낫다고 판단할 가능성이 높다.
	  
- version 1.2 : 캐싱 처리
	- UX를 높이기 위하여 캐싱 처리를 추가한다.
	- 동일한 질문에 대해 반복적으로 GPT를 호출하지 않고, 이전 결과를 Redis에 캐시하여 재사용함으로써 비용을 절감하고 응답 속도를 향상시킨다.
	- 구현 방식
		- 사용자가 질문을 정규화(소문자화, 특수문자 제거 등) 하여 캐시 키를 통일
		- `gpt:cache:{질문}` 형식으로 Redis에 저장하여, 최대 72시간 TTL을 적용
		- 동일 질문이 들어올 경우 GPT 호출 없이 즉시 캐시 응답을 반환
	- 문제점
		- 정규화 한계로 캐시 HIT 누락
			- 질문 표현이 조금만 달라도 캐시 미적용이 될 수 있다.
			- 개선: 의미 기반 정규화, 템플릿 매핑, 유사도 그룹화 적용
		- 오입력, 저품질 응답도 캐시됨
			- 오타·의미 없는 질문도 저장될 수 있다.
			- 개선: 응답 길이/품질 기준으로 캐시 여부 판단
		- 캐시 키 과다 생성 및 메모리 낭비
			- 유사 질문 여러 키로 저장 → 캐시 오염
			- 개선: 키 해시 적용, NLP 기반 질문 통합
		- TTL 만료로 인기 질문 캐시 소멸
			- 자주 쓰는 질문도 TTL 초과로 삭제됨
			- 개선: 캐시 HIT 시 TTL 갱신, LRU/LFU 전략 활용
		- GPT 모델 업데이트 반영 어려움
			- 캐시된 응답이 구버전 기준일 수 있음
			- 개선: 모델 버전을 캐시 키에 포함하거나 주기적 갱신
	  
- version 1.3 : 캐싱 정밀화
---
### 대량의 API를 호출하면 무슨 일이 벌어지는지? 어떻게 모니터링 할지?

### 데이터가 많을 때 조회하는 성능 개선

### 스파이크성 트래픽을 재현

---
### 부하 테스트 시나리오

#### 상황 1 -  10만 명 유저가 동시에 로그인을 시도

- **목적**
	- 인증 서버의 처리량 한계 확인
	- 데이터베이스와 비밀번호 해싱 연산의 병목 발생 여부 점검
- **시나리오**
	- 10만 명의 사용자가 동시에 `/login` 엔드포인트로 로그인 요청
	- 각각의 요청은 이메일과 비밀번호를 포함
	- 로그인 성공 시 JWT 토큰과 RefreshToken을 응답받음
- **측정 항목**
	- **평균 응답 시간**
		- 병목발생 : 10만명 동시 로그인 응답시간이 평균 4200ms 
	- **로그인 성공률**
		- 병목 발생 : 성공률이 대략 60% 미만일 경우
	- **DB 커넥션 풀 사용률**
	- **CPU 사용량 (BCrypt 연산에 의한 부하)**
		- 병목발생 : 95~100%
- **기대 결과**
	- 일정 수준 이상에서 응답 지연 또는 실패 발생
	- Redis를 사용한 RefreshToken 저장 구조의 성능 평가 가능
---
#### 상황 2 - 데이터 폭증 시 조회/검색 성능

- **목적**
	- 게시물 수 증가에 따른 검색 및 조회 API의 응답 성능 측정
	- 페이징, 인덱싱, 캐시 전략의 유효성 평가
- **시나리오**
	- 게시글 100만 건 이상 DB에 사전 적재
	- `/api/posts?page=1` 또는 `/api/search?keyword=xxx`로 1000명 동시 요청
	- 다양한 정렬 조건, 필터 조합을 포함한 요청 시뮬레이션
- **측정 항목**
	- **쿼리 응답 시간**
		- 사용자는 0.3초 이내 응답이 오길 원한다.
		- 1000명이 동시에 검색했을 때, 쿼리 응답 시간이 1초 이상으로 증가한다면 성능 병목 의심
	- **페이지당 응답 데이터 크기**
		- 페이지당 불필요하게 많은 필드를 내려보내면 네트워크 부하 및 클라이언트 랜더링 지연 발생
	- **DB CPU, 메모리 사용량**
		- 부하가 클수록 CPU 100% 근접 > 쿼리 지연 > 메모리 부족 시 > 스왑 발생 > 성능 급저하
		- CPU가 높다 ? > 계산이 많은 쿼리
		- 메모리 사용률이 높다? > 정렬, 조인 인덱스 미사용 추정
	- **느린 쿼리 로그 발생 여부**
		- DB는 자기가 느렸던 쿼리를 자동으로 로그에 남겨준다.
		- 부하 테스트 시 이 로그가 남는다면, 병목 쿼리를 정확하게 찾아서 튜닝할 수 있다.
- **기대 결과**
	- 인덱스 적용 여부에 따라 응답 시간 차이 발생
	- Redis 캐시 적용 여부에 따른 성능 차이 확인 가능
---
#### 상황 3 - 지속적인 트래픽 테스트

- **목적**
	- 장시간 지속적인 요청 처리 시 시스템의 안정성 및 리소스 누수 확인
	- GC 처리, 메모리 누수, 스레드 사용 상태 등 장기적 품질 평가
- **시나리오**
	- 초당 100 TPS 수준의 요청을 2시간 이상 유지
	- `/api/posts`, `/api/users/me`, `/api/videos` 등 다양한 엔드포인트 포함
- **측정 항목**
	- **평균 응답 시간 변화 추이**
		- GC 문제, 리소스 누수, 커넥션 미반납, 스레드 고갈 가능성 추측
	- **메모리 사용량 증가 여부**
		- Heap 메모리가 계속 증가하는지 확인
	- **GC 횟수 및 정지 시간**
	- **WAS 스레드 상태 및 누적 여부**
		- 스레드가 제대로 처리되고 있는지, 계속 누적되고 있진 않은지
- **기대 결과**
	- 정상적으로 GC가 작동하고, 리소스가 일정 수준으로 유지됨
	- 누수 또는 비정상적인 사용량 증가가 없을 경우 성공
---
#### 상황 4 - 동시 요청 폭주 테스트

- **목적**
	- 특정 시점에 갑작스럽게 트래픽이 몰릴 경우 처리 능력 평가
	- API 서버 및 백엔드 병목 지점 식별
- **시나리오**
	- 특정 이벤트 트리거 이후, 1초 내에 1만 명 이상이 동시에 `/api/gpt/qna`, `/api/search` 요청
	- 일부는 로그인 인증 토큰 포함, 일부는 인증되지 않은 상태로 요청
- **측정 항목**
	- **응답 성공률**
		- 전체 요청 수 10000 > 성공 응답 수 6000 > 성공률 60% (심각)
	- **요청 큐 대기 시간**
		- WAS 쓰레드가 꽉 찼을 때 대기열에서 얼마나 오래 기다리는지
	- **WAS 처리 쓰레드 수 변화**
		- 요청이 몰릴 때 쓰레드가 정상적으로 스케일업/스케일다운하는가?
	- **비율별 오류 유형 (429, 503 등)**
		- 429 Too Many Requests
			- 의미 - Rate Limit 초과
			- 원인 - 요청 수 제한 정책
		- 503 Service Unavailable
			- 의미 - 서버가 감당 못 함
			- 원인 - 스레드/리소스 부족
		- 500 Internal Server Error
			- 의미 - 처리 중 오류
			- 원인 - 예외 처리 문제
- **기대 결과**
	- Rate Limiting 또는 예외 처리 정책에 따라 안정적 대응
	- 비정상 요청 비율이 일정 수준 이상이면 적절한 오류 반환
---

### 부하 테스트 도구
#### ✅ 상황 1 – 10만 명 동시 로그인

| 측정 항목 | 설명 | 추천 도구 |
|-----------|------|-----------|
| **평균 응답 시간** | 요청~응답까지 걸린 시간 | `k6`, `Locust`, `JMeter` |
| **로그인 성공률** | 전체 요청 중 200 OK 비율 | `k6 summary`, `Locust stats`, `JMeter Reports` |
| **DB 커넥션 풀 사용률** | 동시 접속 커넥션 수 | Spring Boot `Actuator` (`/actuator/metrics/hikaricp.connections.*`), `Grafana` |
| **CPU 사용량 (BCrypt)** | 해시 연산이 CPU에 끼친 부하 | `top`, `htop`, `VisualVM`, `JFR`, `Grafana` |

---
#### ✅ 상황 2 – 데이터 폭증 시 검색/조회 성능

| 측정 항목 | 설명 | 추천 도구 |
|-----------|------|-----------|
| **쿼리 응답 시간** | DB 쿼리 수행 시간 | `JMeter`, `k6`, `EXPLAIN ANALYZE`, `APM`, `New Relic` |
| **페이지당 응답 데이터 크기** | 전송되는 응답 크기 | 브라우저 `DevTools`, `Postman`, `k6 response.body.length` |
| **DB CPU/메모리 사용량** | 정렬, 조인, 인덱스 미사용 시 부하 | `top`, `htop`, `Grafana`, `VisualVM`, `CloudWatch` |
| **느린 쿼리 로그** | 느린 쿼리 자동 기록 | MySQL `slow_query_log`, `pg_stat_statements`, `pt-query-digest` |

---
#### ✅ 상황 3 – 지속적인 트래픽 테스트

| 측정 항목 | 설명 | 추천 도구 |
|-----------|------|-----------|
| **평균 응답 시간 변화 추이** | 시간 경과에 따라 느려지는지 확인 | `k6 stages`, `Grafana`, `APM`, `Prometheus` |
| **메모리 사용량 증가 여부** | Heap 메모리 점유율 추이 | `VisualVM`, `JFR`, `Prometheus`, `Grafana`, `/metrics/jvm.memory.used` |
| **GC 횟수 및 정지 시간** | Full GC 발생 여부, GC Stop-the-world 시간 | `JVM GC 로그`, `JFR`, `VisualVM`, `Spring Actuator` |
| **WAS 스레드 상태 및 누적 여부** | BLOCKED, RUNNABLE 스레드 감지 | `jstack`, `Actuator`, `Grafana`, `/metrics/jvm.threads.states` |

---

#### ✅ 상황 4 – 동시 요청 폭주 테스트

| 측정 항목 | 설명 | 추천 도구 |
|-----------|------|-----------|
| **응답 성공률** | 2xx 응답 비율 측정 | `k6 summary`, `JMeter`, `Artillery` |
| **요청 큐 대기 시간** | 쓰레드 큐가 꽉 찼을 때 대기 시간 | `Spring Async`, `NGINX queue`, `APM`, `Grafana` |
| **WAS 처리 쓰레드 수 변화** | 요청에 따라 스레드 스케일업 여부 | `jstack`, `Grafana`, `/metrics/jvm.threads.states` |
| **오류 유형 분석 (429, 503, 500)** | 에러 코드 분포 확인 | `k6`, `JMeter`, `Artillery`, `CloudWatch`, `Spring log` |

---


---
- [부하 시나리오](https://www.google.com/search?q=%EB%B6%80%ED%95%98+%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4&oq=%EB%B6%80%ED%95%98+%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4&gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIGCAEQABgeMgYIAhAAGB4yBggDEAAYHjIGCAQQABgeMgYIBRAAGB4yBggGEAAYHjIGCAcQABgeMgYICBAAGB4yBggJEAAYHtIBCDE1MjNqMGo3qAIAsAIA&sourceid=chrome&ie=UTF-8)
- [Redis 설치 방법](https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-Window10-%ED%99%98%EA%B2%BD%EC%97%90-Redis-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0)
- [Redis Refresh Token](https://byungil.tistory.com/309)
---
### 참고 문헌 - 김용수님

- **1. 의존방향을 도메인 방향으로만 흐르도록하여 외부 요소의 변경에 취약하지 않도록 설계**
	- **코드 복잡성을 높이지 않기 위해 인터페이스를 과도하게 사용하지 않도록 함***
	- 내 프로젝트에 적용이 가능할 것 같다.
	- (계획 작성)
---
 - **2. AWS SQS를 이용하여 푸시 서버와의 연동을 비동기 방식으로 구현**
	- **시스템 간의 의존도를 낮추고, 트래픽 급증 시에도 안정적인 푸시 알림 전달하기 위함**
	- 내 프로젝트에 적용하기 위해선 알람 기능을 추가해야한다.
	- 알림이 아니어도 시간이 오래 걸리거나 실패/재시도 가능성이 있는 작업은 전부 큐로 빼는 게 좋을 것 같다.
	- 당장은 기능 추가보다 적용할 수 있는 기능을 구상해보자.
	
	- **2.1 아이디어**
		- 내 플레이리스트 동영상 썸네일 생성? / 영상 인코딩?
			- 사용자가 영상을 업로드하면, 그 즉시 처리하지 않고 백그라운드에서 썸네일 생성 혹은 인코딩을 수행
			- 영상 파일 업로드만 빠르게 끝내고,  실제 썸네일 생성은 메시지 큐(SQS, 메모리 큐 등)에 넘겨서 처리
			-  업로드 시 UX 빠름, - 트래픽 많아도 서버가 감당 가능, 처리 실패 시 재시도도 가능
		
		- 사용자 활동 기록 저장 (Audit 로그)
			- 사용자의 로그인, 재생목록 추가, 영상 재생, 좋아요 클릭 등을 메시지 형태로 큐에 쌓고, 별도 DB 혹은 로그 서버에 기록
			- 서비스 흐름에 방해 없이 로그 수집 가능
			- 추후 통계, 분석, 추천 로직에 활용 가능
		  
		- 이메일 인증 / 회원가입 후 환영 메일 발송
			- 회원가입 완료 시, 이메일 발송 요청을 바로 처리하지 않고 큐에 넣음
			- 별도 worker에서 메일 서버와 연결해 발송
			- 메일 서버 응답 지연으로 인해 회원가입 UX가 느려지는 걸 방지
			- 메일 서버 장애 시에도 재시도 로직 가능
		  
	- **2.2. SQS 대처 방법**
		1. 스프링에서 @Async + 스레드풀 사용
		2. 메모리 기반 BlockingQueue 사용해서 간이 큐 만들기
		3. DB 기반 큐 구현 (장기적 작업용)
  ---
- **3. Spring Security를 사용해 익명 사용자 및 인증된 사용자의 다양한 활동에 대한 접근 제어 리스트(ACL)를 구현하고, 행위별 보안 정책을 적용**
	- 유저 정보 
		- 내정보 조회 - 로그인한 사용자만
		- 유저 강제 정지 - ADMIN 권한만
	- 재생목록
		- 생성 - 로그인한 사용자만
		- 조회 - 공개일 경우 누구나, 비공개일 경우 소유자만
		- 수정/삭제 - 생성자(소유자)만 할 수 있다.
---
- **4. 단위, 통합 테스트 케이스 300여개 작성**
- 
---







