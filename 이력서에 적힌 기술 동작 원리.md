
---

---
##### 1. 부하 테스트 설계와 도구 선정
- **k6**
    - **목적**
        - 코드로 작성하고, CLI에서 실행하는 개발자 친화적 테스트 도구
    - **동작 원리**
        - JavaScript 테스트 스크립트 작성
        - k6 런타임이 스크립트를 해석
        - 가상 사용자(VU)를 Go루틴(goroutine)으로 생성
        - 각 VU가 HTTP 요청을 병렬 실행하고 메트릭 수집
    - **장점**
        - 높은 성능 효율
            - Go 기반, 경량 VU 모델 -> 동일 자원 대비 높은 동시성
        - 자동화, CI/CD 친화적
            - CLI 중심 -> Git, CI 파이프라인에 바로 연결
        - 뛰어난 재현성
        - GUI 클릭이 아닌 코드 -> 테스트 조건이 항상 동일
    - **단점**
        - 비개발자 진입 장벽
            - GUI 없음, Javascript 필수
        - 복잡한 시나리오 가시성 부족
            - Jmeter처럼 플로우를 시각적으로 보며 설계하기 어려움
        - 프로토콜 확장 제한
            - HTTP 중심, 특수 프로토콜은 확장 필요
    - **한 문장 기억 공식**
        - k6는 GUI를 버리고 Javascript와 Go를 선택해, 빠르고 자동화에 강한 대신 비개발자 친화성을 포기한 부하 테스트 도구이다.
    - **장단점 연결 기억법**
        - 왜 빠른가?
            - Go + goroutine
        - 왜 자동화에 강한가?
            - CLI + 코드 기반
        - 왜 불편한가?
            - GUI 없음
        - 왜 Jmeter와 성격이 다른가?
            - 설계 철학이 다름
      
- **JMeter**
    - **목적**
        - JMeter는 GUI로 복잡한 부하 테스트 시나리오를 설계 및 실행하기 위한 범용 테스트 도구이다.
    - **동작 원리**
        - GUI에서 Test Plan 구성
        - Thread Group이 Thread 단위로 가상 사용자 생성
        - Sampler가 요청을 실행
        - Listener가 결과를 수집 및 시각화
    - **장점**
        - 복잡한 시나리오 설계에 강함
            - 조건 분기, 반복, 컨트롤러 구조를 시각적으로 조립 가능
        - 프로토콜 지원 범위가 넓음
            - HTTP, JDBC, FTP, JMS 등 다양한 프로토콜 지원
        - 비개발자도 접근 가능
            - 코드 작성 없이 테스트 구성 가능
    - **단점**
        - 고부하 시 자원 소모 큼
            - Java Thread 모델 -> 메모리, CPU 사용량 증가
        - GUI 실행 시 성능 왜곡 위험
            - Listener, GUI 렌더링이 부하 테스트 결과에 영향
        - 자동화 및 버전 관리의 불리함
            - GUI 기반 설정은 코드 기반 도구보다 재현성이 낮음
    - **한 문장 기억 공식**
        - JMeter는 GUI와 Java Thraed를 선택해 복잡한 시나리오에 강하지만, 대규모 부하와 자동화에는 불리한 도구이다.
    - **장단점 연결 기억법**
        - 왜 시나리오가 강한가? 
            - GUI + 컨트롤러 구조
        - 왜 무거운가? 
            - Java Thread 기반
        - 왜 CLI 실행이 권장되는가? 
            - GUI 성능 간섭 제거
        - 왜 k6와 다르게 쓰는가? 
            - 목표 사용자가 다름
      
- **nGrinder**
    - **목적**
        - 웹 UI로 분산 부하 테스트를 쉽게 운영하기 위한 엔터프라이즈용 도구
    - **동작 원리**
        - Controller에서 테스트 시나리오 관리 (웹 UI)
        - 테스트 실행 시 Agent 여러 대에 작업 분배
        - Agent 내부에서 Grinder 엔진 + Jython/Groovy 스크립트 실행
        - 각 Agent의 결과를 Controller가 수집 및 통합
    - **장점**
        - 대규모 분산 부하 테스트에 유리
            - Agent를 수평 확장하여 부하 생성 가능
        - 웹 UI 기반 관리 편의성
            - 테스트 실행, 모니터링, 결과 확인을 한 화면에서 처리
        - 조직 단위 운영에 적합
            - 테스트 이력, 사용자 관리, 권한 관리 제공
    - **단점**
        - 구성 복잡도 높음
            - Controller, Agent, 네트워크 설정 필요
        - 스크립트 작성 난이도
            - Jython/Groovy 기반 -> Java 계열 이해 필요
        - 경량 테스트에는 과함
            - 단일 서버, 간단한 테스트에는 오버엔지니어링
    - **한 문장 기억 공식**
        - nGrinder는 중앙 Controller와 분산 Agent를 선택해 대규모 부하에는 강하지만, 설정과 운영이 무거운 도구이다.
    - **장단점 연결 기억법**
        - 왜 대규모에 강한가? 
            - 분산 Agent 구조
        - 왜 운영이 편한가? 
            - 웹 UI + 중앙 관리
        - 왜 복잡한가? 
            - Controller - Agent 인프라 필요
        - 왜 개인 프로젝트에는 과한가? 
            - 엔터프라이즈 지향 설계
      
- **Locust**
    - **목적**
        - Python 코드로 사용자 행동을 자연스럽게 표현하는 분산 부하 테스트 도구이다.
    - **동작 원리**
        - Python으로 사용자 행동(User behavior) 정의
        - Master 노드가 테스트를 제어
        - 여러 Worker 노드가 가상 사용자 실행
        - 결과를 Master에서 실시간 집계 및 웹 UI로 표시
    - **장점**
        - 사용자 행동 표현력이 뛰어남
            - Python 코드로 조건, 상태, 흐름을 자유롭게 표현
        - 분산 부하 테스트 용이
            - Worker 수평 확장으로 부하 증가 가능
        - 실시간 모니터링
            - 웹 UI에서 요청 수, 응답 시간, 실패율을 즉시 확인
    - **단점**
        - Python 성능 한계
            - 고부하에서는 CPU 사용량 증가, 효율성 k6 대비 낮음
        - 완전한 자동화에는 추가 작업 필요
            - 웹 UI 중심 -> CI 환경에선 설정 필요
        - 엔터프라이즈 기능 부족
            - 권한 관리, 테스트 이력 관리 등은 제한적
    - **한 문장 기억 공식**
        - Lucst는 Python으로 사용자 행동을 자연스럽게 표현하는 대신, 극단적인 성능 효율은 포기한 부하 테스트 도구이다.
    - **장단점 연결 기억법**
        - 왜 시나리오가 자연스러운가?
            - Python 코드 기반
        - 왜 분산이 쉬운가?
            - Master-Worker 구조
        - 왜 성능이 k6보다 약한가?
            - Python 런타임
        - 왜 개발자가 선호하는가?
            - 학습 비용 낮음

##### 2. 트래픽 부하 분산을 위한 로드 밸런서 구축
- **nginx**
    - **목적**
    - **동작 원리**
    - **장점**
    - **단점**
    - **한 문장 기억 공식**
    - **장단점 연결 기억법**
      
- 
    - **목적**
    - **동작 원리**
    - **장점**
    - **단점**
    - **한 문장 기억 공식**
    - **장단점 연결 기억법**
    
- 
    - **목적**
    - **동작 원리**
    - **장점**
    - **단점**
    - **한 문장 기억 공식**
    - **장단점 연결 기억법**
    
- 
    - **목적**
    - **동작 원리**
    - **장점**
    - **단점**
    - **한 문장 기억 공식**
    - **장단점 연결 기억법**
    
- 
    - **목적**
    - **동작 원리**
    - **장점**
    - **단점**
    - **한 문장 기억 공식**
    - **장단점 연결 기억법**

##### 2.
##### 2.
##### 2.
##### 2.
##### 2.
##### 2.

