
---
- [[CS]]
---


### 병합 정렬 Merge Sort

- 벙합 정렬의 동작은 **분할(Divide)**, **정복(Conquer)**, **병합(Merge)** 3단계를 반복하는 생명주기를 가지고 있다
	
- 분할 단계 (Divide)
	- 배열을 두 개의 하위 배열로 나눕니다.
	- 이 과정을 **재귀적으로** 반복하며, 배열의 크기가 1이 될 때까지 계속 나누어 갑니다.
	- 배열의 크기가 1이 되면 더 이상 나눌 수 없으므로 이 단계는 종료됩니다.
	
- 예시
	- 입력 배열
		- `[38, 27, 43, 3, 9, 82, 10]`
    - 분할 → 왼쪽: `[38, 27, 43]` / 오른쪽: `[3, 9, 82, 10]`
    - 다시 분할 → `[38]`, `[27, 43]` / `[3, 9]`, `[82, 10]`
    - 더 분할 → `[27]`, `[43]` / `[3]`, `[9]`, `[82]`, `[10]`
	- 결과적으로 각 배열이 1개 원소로 나뉘게 된다.
		- `[38]`, `[27]`, `[43]`, `[3]`, `[9]`, `[82]`, `[10]`
	
- 정복 단계 (Conquer)
	- 분할된 작은 배열들을 비교하고, 두 개씩 정렬하면서 병합을 시작합니다.
	- 작은 배열에서 큰 배열로 합쳐지며, 정렬된 상태를 유지합니다.
	- 이 과정은 재귀 호출이 종료되면서 **재귀 호출이 반환되는 순서대로** 실행됩니다.
	  
- 예시
	- `[27]`과 `[43]` 병합 → `[27, 43]`
	- `[38]`과 `[27, 43]` 병합 → `[27, 38, 43]`
	- `[3]`과 `[9]` 병합 → `[3, 9]`
	- `[82]`과 `[10]` 병합 → `[10, 82]`
	- `[3, 9]`과 `[10, 82]` 병합 → `[3, 9, 10, 82]`
	
- 병합 단계 (Merge)
	- 정렬된 하위 배열들을 다시 병합하면서 원래 크기의 배열로 합쳐나갑니다.
	- 최종적으로 모든 하위 배열이 병합되어 **완전한 정렬된 배열**이 생성됩니다.
	
- 예시
	- `[27, 38, 43]`과 `[3, 9, 10, 82]` 병합 → `[3, 9, 10, 27, 38, 43, 82]`
	
-  병합 정렬의 전체 생명주기 요약:
	1. **분할 (Divide):** 배열을 절반씩 나누어 더 이상 나눌 수 없을 때까지 반복합니다.
	2. **정복 (Conquer):** 각 하위 배열에서 정렬하면서 병합합니다.
	3. **병합 (Merge):** 병합된 하위 배열을 다시 합쳐 최종 정렬된 배열을 만듭니다.
	
- 시간복잡도
	- `O(n log n)`
	- n개 만큼씩 log n번 돌기 때문이다.
	
- 병합 정렬은 실행시에 별도의 저장공간이 필요로하다.
- 공간을 사용할 수 없는 경우는 퀵 정렬을 해야 한다.
	  
- 코드 실행시 각 단계별 진행 과정
```java
코드 실행 시 각 단계별 진행 과정

1.초기 배열 → 
	
	`[38, 27, 43, 3, 9, 82, 10]`
    
2.분할 완료 후 배열들 → 
	
	`[38]`, `[27]`, `[43]`, `[3]`, `[9]`, `[82]`, `[10]`
    
3.병합 진행 중 →
	
    - `[27] + [43]` → `[27, 43]`
    - `[38] + [27, 43]` → `[27, 38, 43]`
    - `[3] + [9]` → `[3, 9]`
    - `[82] + [10]` → `[10, 82]`
    - `[3, 9] + [10, 82]` → `[3, 9, 10, 82]`
    - `[27, 38, 43] + [3, 9, 10, 82]` → `[3, 9, 10, 27, 38, 43, 82]`
	
4. 최종 배열 → 
	
	 `[3, 9, 10, 27, 38, 43, 82]`
    
```
		  
- 예제 코드
```java
import java.util.Arrays;

public class MergeSort {

    // 병합 정렬 함수
    public static void mergeSort(int[] array) {
        // 배열의 길이가 1 이하인 경우 정렬할 필요 없음
        if (array.length < 2) {
            return;
        }
		
        // 배열을 두 부분으로 나눔
        int mid = array.length / 2;
        int[] left = Arrays.copyOfRange(array, 0, mid);
        int[] right = Arrays.copyOfRange(array, mid, array.length);
		
        // 재귀적으로 두 부분을 정렬
        mergeSort(left);
        mergeSort(right);
		
        // 두 정렬된 배열을 병합
        merge(array, left, right);
    }
	
    // 두 배열을 병합하는 함수
    public static void merge(int[] array, int[] left, int[] right) {
        int i = 0, j = 0, k = 0;
		
        // 왼쪽 배열과 오른쪽 배열을 비교하면서 작은 값을 array에 채워 넣음
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                array[k] = left[i];
                i++;
            } else {
                array[k] = right[j];
                j++;
            }
            k++;
        }
		
        // 왼쪽 배열에 남아있는 값이 있으면 넣어줌
        while (i < left.length) {
            array[k] = left[i];
            i++;
            k++;
        }
		
        // 오른쪽 배열에 남아있는 값이 있으면 넣어줌
        while (j < right.length) {
            array[k] = right[j];
            j++;
            k++;
        }
    }
	
    // 테스트용 main 함수
    public static void main(String[] args) {
        int[] array = {38, 27, 43, 3, 9, 82, 10};
        
        System.out.println("원본 배열: " + Arrays.toString(array));
        
        mergeSort(array); // 병합 정렬 수행
        
        System.out.println("정렬된 배열: " + Arrays.toString(array));
    }
}
```
	
- 학습자료
	https://www.youtube.com/watch?v=QAyl79dCO_k##### 병합 정렬 Merge Sort

- 벙합 정렬의 동작은 **분할(Divide)**, **정복(Conquer)**, **병합(Merge)** 3단계를 반복하는 생명주기를 가지고 있다
	
- 분할 단계 (Divide)
	- 배열을 두 개의 하위 배열로 나눕니다.
	- 이 과정을 **재귀적으로** 반복하며, 배열의 크기가 1이 될 때까지 계속 나누어 갑니다.
	- 배열의 크기가 1이 되면 더 이상 나눌 수 없으므로 이 단계는 종료됩니다.
	
- 예시
	- 입력 배열
		- `[38, 27, 43, 3, 9, 82, 10]`
    - 분할 → 왼쪽: `[38, 27, 43]` / 오른쪽: `[3, 9, 82, 10]`
    - 다시 분할 → `[38]`, `[27, 43]` / `[3, 9]`, `[82, 10]`
    - 더 분할 → `[27]`, `[43]` / `[3]`, `[9]`, `[82]`, `[10]`
	- 결과적으로 각 배열이 1개 원소로 나뉘게 된다.
		- `[38]`, `[27]`, `[43]`, `[3]`, `[9]`, `[82]`, `[10]`
	
- 정복 단계 (Conquer)
	- 분할된 작은 배열들을 비교하고, 두 개씩 정렬하면서 병합을 시작합니다.
	- 작은 배열에서 큰 배열로 합쳐지며, 정렬된 상태를 유지합니다.
	- 이 과정은 재귀 호출이 종료되면서 **재귀 호출이 반환되는 순서대로** 실행됩니다.
	  
- 예시
	- `[27]`과 `[43]` 병합 → `[27, 43]`
	- `[38]`과 `[27, 43]` 병합 → `[27, 38, 43]`
	- `[3]`과 `[9]` 병합 → `[3, 9]`
	- `[82]`과 `[10]` 병합 → `[10, 82]`
	- `[3, 9]`과 `[10, 82]` 병합 → `[3, 9, 10, 82]`
	
- 병합 단계 (Merge)
	- 정렬된 하위 배열들을 다시 병합하면서 원래 크기의 배열로 합쳐나갑니다.
	- 최종적으로 모든 하위 배열이 병합되어 **완전한 정렬된 배열**이 생성됩니다.
	
- 예시
	- `[27, 38, 43]`과 `[3, 9, 10, 82]` 병합 → `[3, 9, 10, 27, 38, 43, 82]`
	
-  병합 정렬의 전체 생명주기 요약:
	1. **분할 (Divide):** 배열을 절반씩 나누어 더 이상 나눌 수 없을 때까지 반복합니다.
	2. **정복 (Conquer):** 각 하위 배열에서 정렬하면서 병합합니다.
	3. **병합 (Merge):** 병합된 하위 배열을 다시 합쳐 최종 정렬된 배열을 만듭니다.
	
- 시간복잡도
	- `O(n log n)`
	- n개 만큼씩 log n번 돌기 때문이다.
	
- 병합 정렬은 실행시에 별도의 저장공간이 필요로하다.
- 공간을 사용할 수 없는 경우는 퀵 정렬을 해야 한다.
	  
- 코드 실행시 각 단계별 진행 과정
```java
코드 실행 시 각 단계별 진행 과정

1.초기 배열 → 
	
	`[38, 27, 43, 3, 9, 82, 10]`
    
2.분할 완료 후 배열들 → 
	
	`[38]`, `[27]`, `[43]`, `[3]`, `[9]`, `[82]`, `[10]`
    
3.병합 진행 중 →
	
    - `[27] + [43]` → `[27, 43]`
    - `[38] + [27, 43]` → `[27, 38, 43]`
    - `[3] + [9]` → `[3, 9]`
    - `[82] + [10]` → `[10, 82]`
    - `[3, 9] + [10, 82]` → `[3, 9, 10, 82]`
    - `[27, 38, 43] + [3, 9, 10, 82]` → `[3, 9, 10, 27, 38, 43, 82]`
	
4. 최종 배열 → 
	
	 `[3, 9, 10, 27, 38, 43, 82]`
    
```
		  
- 예제 코드
```java
import java.util.Arrays;

public class MergeSort {

    // 병합 정렬 함수
    public static void mergeSort(int[] array) {
        // 배열의 길이가 1 이하인 경우 정렬할 필요 없음
        if (array.length < 2) {
            return;
        }
		
        // 배열을 두 부분으로 나눔
        int mid = array.length / 2;
        int[] left = Arrays.copyOfRange(array, 0, mid);
        int[] right = Arrays.copyOfRange(array, mid, array.length);
		
        // 재귀적으로 두 부분을 정렬
        mergeSort(left);
        mergeSort(right);
		
        // 두 정렬된 배열을 병합
        merge(array, left, right);
    }
	
    // 두 배열을 병합하는 함수
    public static void merge(int[] array, int[] left, int[] right) {
        int i = 0, j = 0, k = 0;
		
        // 왼쪽 배열과 오른쪽 배열을 비교하면서 작은 값을 array에 채워 넣음
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                array[k] = left[i];
                i++;
            } else {
                array[k] = right[j];
                j++;
            }
            k++;
        }
		
        // 왼쪽 배열에 남아있는 값이 있으면 넣어줌
        while (i < left.length) {
            array[k] = left[i];
            i++;
            k++;
        }
		
        // 오른쪽 배열에 남아있는 값이 있으면 넣어줌
        while (j < right.length) {
            array[k] = right[j];
            j++;
            k++;
        }
    }
	
    // 테스트용 main 함수
    public static void main(String[] args) {
        int[] array = {38, 27, 43, 3, 9, 82, 10};
        
        System.out.println("원본 배열: " + Arrays.toString(array));
        
        mergeSort(array); // 병합 정렬 수행
        
        System.out.println("정렬된 배열: " + Arrays.toString(array));
    }
}
```
	
- 학습자료
	https://www.youtube.com/watch?v=QAyl79dCO_k