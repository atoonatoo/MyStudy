---
created:
---

---
- 
---
### 1. 개요

자바의 가비지 컬렉션은 메모리 관리를 자동으로 수행하는 기법이다.  
자바 가상 머신(JVM)은 개발자가 명시적으로 메모리를 해제하지 않아도, 사용하지 않는 객체를 자동으로 제거하여 메모리 누수를 방지한다.  
이와 같이 가비지 컬렉션은 안정적이고 효율적인 메모리 관리를 위해 필수적인 요소이다.

---

### 2. 특징

자바의 가비지 컬렉션은 다음과 같은 특징을 가진다.

- **자동 메모리 관리**  
  JVM이 객체의 생성과 소멸을 관리한다.
  
- **메모리 누수 방지**  
  더 이상 참조되지 않는 객체를 자동으로 제거하여 메모리 누수를 줄인다.
  
- **프로그램의 복잡성을 낮춘다.**  
  개발자가 메모리 해제에 대해 고민할 필요가 없다.
  
- **다양한 알고리즘을 지원한다.**  
  애플리케이션의 특성에 따라 적절한 GC 알고리즘을 선택할 수 있다.

---

### 3. 동작원리

자바의 가비지 컬렉션은 다음과 같은 순서로 동작한다.

1. **객체 생성**  
   객체가 생성되면 힙(heap) 영역에 할당된다.
   
2. **루트 집합 탐색**  
   스택, 전역 변수, 레지스터 등 루트 집합에서 시작하여 모든 접근 가능한 객체를 탐색한다.
   
3. **마크 단계**  
   접근 가능한 객체에 ‘사용 중’임을 표시한다.
   
4. **스윕 단계**  
   힙 전체를 순회하며 마크되지 않은 객체를 찾아 메모리에서 해제한다.
   
5. **메모리 재활용**  
   해제된 메모리 영역을 재사용할 수 있도록 준비한다.

---

### 4. 주요 알고리즘

자바에서는 다양한 가비지 컬렉션 알고리즘을 지원한다.

- **마크-스윕(Mark-and-Sweep) 알고리즘**  
  루트 집합부터 시작하여 모든 접근 가능한 객체를 마크한 후, 마크되지 않은 객체를 제거한다.
  
- **마크-컴팩트(Mark-and-Compact) 알고리즘**  
  마크 단계 이후에 메모리 단편화를 줄이기 위해 객체들을 한쪽으로 몰아서 정리한다.
  
- **병렬 가비지 컬렉션**  
  멀티스레드를 활용하여 가비지 컬렉션 작업을 병렬로 수행함으로써 애플리케이션 정지 시간을 단축한다.
  
- **콘커런트 가비지 컬렉션**  
  애플리케이션의 실행과 동시에 가비지 컬렉션을 수행하여 일시 중단 시간을 최소화한다.

---

### 5. 장단점

자바의 가비지 컬렉션은 다음과 같은 장단점을 가진다.

**장점**

- **자동 메모리 관리**  
  개발자가 메모리 해제에 대해 직접 신경 쓸 필요가 없다.
  
- **메모리 누수 감소**  
  더 이상 사용되지 않는 객체를 자동으로 제거하여 메모리 누수를 방지한다.
  
- **프로그램 안정성 향상**  
  메모리 관리 오류로 인한 크래시를 예방한다.

**단점**

- **애플리케이션 정지**  
  GC가 수행되는 동안 일시적으로 애플리케이션 실행이 중단된다.
  
- **예측 불가능한 성능**  
  GC의 타이밍에 따라 성능 저하가 발생할 수 있다.
  
- **추가적인 메모리 오버헤드**  
  GC 관리에 필요한 메타데이터와 알고리즘 구현으로 인해 메모리 사용량이 증가할 수 있다.

---

### 6. 참조 카운팅

참조 카운팅은 각 객체에 참조 수를 기록하여 관리하는 방식이다.

- **객체 생성 시 참조 수가 1이다.**  
  객체가 생성될 때 참조 카운트는 1로 초기화된다.
  
- **참조 추가 시 참조 수를 증가시킨다.**  
  객체를 참조하는 새로운 변수가 생성되면 카운트가 증가한다.
  
- **참조 제거 시 참조 수를 감소시킨다.**  
  참조가 제거되면 카운트가 감소한다.
  
- **참조 수가 0이 되면 해제된다.**  
  참조 수가 0이 되는 경우, 해당 객체는 더 이상 사용되지 않는다고 판단되어 메모리에서 제거된다.
  
단, 순환 참조가 발생하는 경우 참조 카운팅 방식으로는 해결이 어려워 추가적인 처리가 필요하다.

---

### 7. 세대별 가비지 컬렉션

세대별 가비지 컬렉션은 객체의 수명을 기반으로 메모리 영역을 분리하여 관리한다.

- **Young Generation(신생 세대)**  
  새로 생성된 객체가 할당되는 영역이다. 대부분의 객체가 이 영역에서 빠르게 소멸한다.
  
- **Old Generation(노년 세대)**  
  Young Generation에서 살아남은 객체가 이동하는 영역이다. 비교적 오래 살아남은 객체들이 위치한다.
  
- **Permanent Generation/Metaspace**  
  클래스 메타데이터나 정적 리소스를 저장하는 영역이다.
  
세대별 GC는 Young Generation에서 Minor GC를 자주 수행하여 단기간에 많은 객체를 제거하고, Old Generation에서는 Major GC를 수행하여 오래된 객체를 정리한다.  
이와 같이 세대별 관리는 전체 GC 수행 시간을 단축하고, 애플리케이션의 정지 시간을 최소화한다.

---

### 8. 결론

자바의 가비지 컬렉션은 자동 메모리 관리로 개발자의 부담을 줄인다.  
다양한 알고리즘(마크-스윕, 마크-컴팩트, 병렬 및 콘커런트 GC)을 통해 메모리 누수를 방지하며, 애플리케이션의 안정성을 높인다.  
참조 카운팅과 세대별 GC 등 각 방식은 장단점이 존재하며, 애플리케이션의 특성에 따라 적절한 방법을 선택하여 사용할 수 있다.  
이와 같이 자바의 가비지 컬렉션은 메모리 관리의 효율성을 극대화하는 중요한 기술이다.

---
# 참고 문헌

	- [#](#)
---