
---
- [[CS]]
---

# 1. HTTP / IP / TCP / UDP 는 모두 프로토콜이다.

프로토콜은 클라이언트와 서버가 서로 정보를 교환할 수 있도록 하는 메세지 형식에 대한 규칙을 의미한다.

수신 호스트가 전송 받은 메시지를 이해하려면 설계된 규칙에 따라 작성된 데이터 형식이어야 한다는 말이다.

예를들어 HTTP 메세지 헤더도 결국 일종의 규칙이며, IP의 숫자도 규칙이라고 말할 수 있다.

만일 규칙을 개는 256.256.256.256 와 같은 형식은 존재하지도 않는 아이피이며 작동하지도 않는다.

HTTP와 IP 프로토콜에 대해서 배우게되면 바로 그 다음 접해보는 프로토콜 쌍둥이가 바로 TCP/UDP 일 것이다.

다만 이 TCP와 UDP에 대해서 귀가 아플 정도로 들어봤겠지만 아무리 들어도 개념이 애매하게 느껴진다. 

왜냐하면 HTTP 같은 경우 브라우저의 개발자 도구의 네트워크, 탭에서 HTTP 메세지의 헤더(Header)로 어떠한 구조로 메세지를 주고 받는지 눈으로 결과값을 확인할 수 있으며, 

또한 IP같은 경우 192.168.10.1 같이 숫자로 이루어져 무언가 주소값을 나타내고 있다는 것임을 알 수 있고, 

브라우저에 아이피로 접속하면 해당 홈페이지로 이동해 어떠한 네트워킹 동작이 일어나고 있음을 직감할 수 있기 때문이다.

![](https://velog.velcdn.com/images/atoonatoo/post/60893871-73b3-4ec5-8a46-f3b5473006c5/image.png)

그러나 TCP / UDP는 이론적인 내용에만 그쳐서 실질적으로 크게 와닿지 않고 완벽하게 이해를 하지 못하였다.

따라서 이론에 그치지않고 시각적으로 개념들을 학습하고, 상대적으로 빈약하게 배우는 UDP에 대해서 최신 기술인 HTTP 3.0를 배우고, 왜 각광받는지 알아 볼 것이다.

---

# 2. TCP (Transmission Control Protocol) - 전송 제어 프로토콜

IP(Internet Protocol)가 인터넷 프로토콜로서 **복잡한 인터넷 망 속에서 클라이언트와 서버 간에 통신**을 할 수 있도록 IP 주소와 패킷과 같은 규칙을 통해 통신을 하는 규칙이라면,

TCP(Transmission Control Protocol)는 IP 규칙으로만 튱신하기에 부족하거나, 불안정한 여러 단점들(패킷 순서가 이상하거나, 패킷이 유실)을 커버해, 패킷 전송을 제어하여 **신뢰성을 보증**하는 프로토콜이다.

IP와 TCP 둘다 프로토콜이지만 이 둘은 동일시 되지않는 별개의 규칙이다.

IP 규칙에 써있는대로 목적지까지 다다랐으면, TCP 규칙에는 써있는대로 올바르게 도착했는지 정확히 누구에게 전달되야하는지 하나하나 따진다고 생각하면 된다. 그래서 은행 업무나 메일과 같은 반드시 수신자가 정보를 받아야하는 신뢰성 있는 통신이 필요할 때 사용된다.

---

## 2.1 TCP의 안전성 예시

인터넷 통신을 택배 수하물로 예시로 들어서, IP 프로토콜은 단순히 배달 주소지라고 한다면, TCP 프로토콜은 이 배달지가 문제없이 잘 전송되기 위해 택배 스티커를 포함한 여러가지 정보를 담긴 것을 의미한다. 
순서, 검증, 전송 제어 정보가 들어있어서 IP 주소지로만 배달하기엔 불안정한 부분들을 확실하게 커버하여 배달품이 목적지까지 안전하게 배달되도록 보증한다.

![](https://velog.velcdn.com/images/atoonatoo/post/c16e4c08-311d-42b9-9bef-38c32c0729cf/image.png)

OSI 7 Layer, TCP/IP 4계층에 대한 지식을 알고있다는 전제하여 예시를 전송 데이터를 포장하는 과정은 다음과 같다.

1. 전송 데이터를 TCP 포장한다.
2. 포장한 전송데이터를 IP 포장한다.
3. 포장한 전송데이터를 이더넷 포장한다.
4. 인터넷을 통해상대 컴퓨터 서버에 도달하여 포장된걸 하나씩 풀며 전송데이터를 받게 된다.

![](https://velog.velcdn.com/images/atoonatoo/post/aeb4e15d-c01a-4cfd-bcc2-5219b46420a2/image.png)

---

## 2.2 TCP의 신뢰성 있는 통신 확인

TCP는 신뢰성을 보장하는 프로토콜이기 때문에 통신전에 목적지가 무사한지 미리 확인하고, 통신 후에도 또 확인해준다. 통신 시작전과, 종료할 때 시작점, 도착점 둘다 통신할 준비가 되어있는지 반드시 미리 먼저 물어보고 패킷을 전송할 순서를 정하고 나서야 본격적인 통신을 시작하기 때문이다.

이러한 과정이 바로 **3 Way Handshake**, **4 Way Handshake** 라고 한다.

둘다 같은 Handshake지만 3 Way는 통신을 시작할 때, 4 Way는 통신을 마칠때 까지 거치는 과정이라는 차이만 있다. 

한마디로 통신하는데 Handshake를 두번 해서 신뢰가 두텁다 못해 과하게 신뢰성을 보장한다는 의미로 이해하면 쉽다.

아래 그림은 클라이언트가 처음 서버와 통신을 하기 위해 TCP 연결을 생성할 때 `SYN`과 `ACK`이라는 패킷을 주고 받고, 통신을 종료하는 과정에서 `FIN`이라는 패킷을 주고 받고 있는 걸 확인할 수 있다.

쉽게 말하면 **내가 너한테 전송하였다는 인증 도장** 정도로 생각하자.

즉, 패킷 내부에 들어있는 인증플래그 값들을 확인하여 클라리언트와 서버가 서로 보낸 패킷의 순서와 패킷을 제대로 받았는 지를 검증 하는 것이다.

![](https://velog.velcdn.com/images/atoonatoo/post/6a336671-f1ee-4ef4-b5a6-05b96471182f/image.png)

---

### 2.2.1 Flag 종류

- **SNY**
	- 접속 요청을 할 때 보내는 패킷을 말한다.
    - TCP 접속시에 가장 먼저 보내는 패킷이다.

- **ACK**
	- 상대방으로부터 패킷을 받은 뒤에, 잘 받았다고 알려주는 패킷을 말한다.
    - 다른 플래그와 같이 출력되는 경우도 있다.

- **PSH**
	- 데이터를 즉시 목적지로 보내라는 의미이다.

- **FIN**
	- 접속 종료를 위한 플래그
    - 이 패킷을 보내는 곳이 현재 접속하고 있는 곳과 접속을 끊고자 할 때 사용한다.

---

### 2.2.2 3-way handshake 과정

![](https://velog.velcdn.com/images/atoonatoo/post/d7c3a4fd-6dad-41c4-aa1e-ba6dab0be1fe/image.png)

1. 클라이언트는 접속을 요청하는 SYN 패킷을 보낸다. 이때 클라이언트는 응답을 기다리기위해 SYN_SENT 상태로 변한다.
2. LISTEN 상태였던 서버는 SYN 요청을 받으면, 클라이언트에게 요청을 수락하는 ACK 패킷과 SYN 패킷을 보낸다. (서버도 클라이언트에 접속해야 양방향 통신이 되기 때문이다.)
그리고 SYN_RCVD(SYN_RECEIVED)상태로 변하여 클라이넌트가 ACK 패킷을 보낼 때 까지 기다리게 된다. 
3. 클라이언트는 다시 서버에 ACK 패킷을 보내고, 이 후 ESTABLISHED 상태가 되어 데이터 통신이 가능하게 된다.
4. 서버도 연결을 닫았다는 신호를 클라이언트가 수신하면 ACK 플래그를 보낸 후 TIME_WAIT 상태로 전환된다. 이 후 모든 것이 끝나면 CLOSED 상태로 변환된다.

---

### 2.2.3 데이터 통신 과정

![](https://velog.velcdn.com/images/atoonatoo/post/d94dc91e-d287-4f05-8b16-08c1e8211bde/image.png)

1. Established 됭 상태에서 서버에게 데이터를 보낸다.
2. 서버는 잘 전송받았다고 ACK 플래그를 넣어 응답한다.
3. 만약 클라이언트가 서버로부터 ACK를 못받았다면 제대로 송신하지 못한걸로 판단하고 데이터를 재전송을 한다.

---

### 2.2.4 4-way handshake 과정

![](https://velog.velcdn.com/images/atoonatoo/post/30a298b0-a8c6-48b3-aff0-08fe50b47b3c/image.png)


1. 서버와 클라이언트가 TCP 연결이 되어있는 상태에서 클라이언트가 접속을 끊기 위해 CLOSE() 함수를 호출한다. 그러면 FIN 플래그를 보내게 되고 클라이언트는 FIN_WAIT1 상태로 변한다.
2. 서버는 클라리언트가 CLOSE() 한다는 것을 알게 되고 CLOSE_WAIT 상태로 바꾼 후 ACK 플래그를 전송한다. 만일 서버에서 클라이언트로 보낼 남은 데이터가 있을 경우 이때 나머지를 모두 전송시킨다.
3. ACK를 받은 클라리언트는 FIN WAIT2로 변환되고, 이때 서버는 CLOSE() 함수를 호출하고 FIN 플래그를 클라이언트에게 보낸다.
4. 서버도 연결을 닫았다는 신호를 클라이언트가 수신하면 ACK 플래그를 보낸 후 TIME_WAIT 상태로 전환된다. 이 후 모든 것이 끝나면 CLOSED 상태로 변환된다.

---

## 2.3 TCP 통신 과정 시각적으로 보기

TCP 핸드쉐이크 과정을 살펴보기위해 Linux 명령어를 이용하여 확인해야 한다.

WireShark라는 무료 소프트웨어를 사용하는 것도 좋지만, 메뉴가 복잡하고 원하는 패킷을 필터링하기도 힘들어 입문자에게는 추천되지 않는다고 한다 추후 WireShark를 이용하여 TCP 핸드 쉐이크 과정을 살펴보는 포스팅을 올리도록 기약하도록 하고, 오늘은 리눅스 터미널로 이용하는 방법을 택했다.

---

### 2.3.1 리눅스 tcpdump 명령어

`tcpdump`라는 Linux 환경에서 Client와 Server가 주고받는 네트워크 패킷을 TCP Layer에서 캡쳐하여 메세지를 확인할 수 있는 명령어이다. UDP도 확인 가능하다.

1. `tcpdump` 명령어를 리눅스에 설치

```bash
# 우분투 설치
$ apt install tcpdump

# CentOS 설치
$ yum install tcpdump
```

2. 다음으로 명령어를 실행한다.

```bash
# 인터넷 통신을 하는 모든 프로토콜을 감지
$ tcpdump -i any -nn port 80
```

![](https://velog.velcdn.com/images/atoonatoo/post/3f88596c-6db9-4dcf-9c14-23d85c642927/image.png)

명령어를 실행하면 위와 같이 인터넷 통신을 감지하는 상태가 된다.

이번에는 새로운 터미널을 하나 더 만들고, 다음과 같이 리눅스의 `netcat(nc)` 명령어로 데이터 통신을 행한다,

```bash
# "Hello World" 라는 데이터를 TCP로 naver.com 에 80번 포트로 전송
$ echo "Hello World" | nc naver.com 80
```

![](https://velog.velcdn.com/images/atoonatoo/post/a65465f9-4d9a-4279-9c66-167c22ca0fa1/image.png)

새로운 터미널에서 데이터를 보내게되면 기존 tcpdump 명령어를 실행하고 Listen 상태였던 터미널에서 통신을 받아 로그를 띄우게 된다.

![](https://velog.velcdn.com/images/atoonatoo/post/fe99fba2-b162-42f3-a9dc-e87c6b489382/image.png)

먼저 10.0.2.15:57744은 클라이언트 아이피이고, 223.130.200.104:80는 서버 아이피이다.

각 라인의 첫번째 필드는 `보낸 사람 > 받는 사람`을 의미하고 있다. 그리고 옆에 `Flags [S]`라는 것이 붙어있는데, 대괄호 안의 대문자는 위에서 살펴본 플래그를 의미한다.

![](https://velog.velcdn.com/images/atoonatoo/post/ec426d9e-3951-4d8a-803e-1f55cb4a63c4/image.png)

지금 위의 상태는 하나의 TCP 연결 및 데이터 전송과 종료 전체의 통신 과정을 행한 상태이다.

---

### 2.3.2 3-way handshake 과정

![](https://velog.velcdn.com/images/atoonatoo/post/09ed86bd-5842-469f-91d7-839fdf0900d1/image.png)

![](https://velog.velcdn.com/images/atoonatoo/post/40f68273-bde5-42f1-81d8-97b2d751065f/image.png)

1. 클라이언트(10.0.2.15) > 서버(223.130.200.104) : SYN
2. 서버(223.130.200.104) > 클라이언트(10.0.2.15) : SYN ACK
3. 클라이언트(10.0.2.15) > 서버(223.130.200.104) : ACK

- seq 
	번호는 순서 번호로서 패킷의 전달 순서를 식별하는데 사용되는 값이다. 
    운영체제의 의해서 랜덤하게 생성되서 SYN 패킷에 담겨 보내진다. 
    그리고 이를 받은 서버에는 동기화에 대한 답신으로 seq 번호를 +1 증가시키고 
    ack에 담아 응답한다.

---

### 2.3.3 데이터 통신 과정

![](https://velog.velcdn.com/images/atoonatoo/post/ec3941bf-6eff-4ee9-b80f-83204ba4cac0/image.png)

![](https://velog.velcdn.com/images/atoonatoo/post/7aae9f55-8f41-4558-8057-31c1d181912b/image.png)

1. 클라이언트(10.0.2.15) > 서버(223.130.200.104) : PSH ACK
2. 서버(223.130.200.104) > 클라이언트(10.0.2.15) : ACK

---

### 2.3.4 4-way handshake 과정

![](https://velog.velcdn.com/images/atoonatoo/post/6fd4be6c-5e4d-4303-b5e4-514e67edcbf1/image.png)

![](https://velog.velcdn.com/images/atoonatoo/post/d5c0d5ec-63cb-4195-8a16-ac86d9c823ec/image.png)

그림상에서는 클라이언트가 먼저 종료 신호를 보냈지만, 리눅스 상에서는 서버가 먼저 종료 신호를 보낸 거꾸로된 상황이다. 그래서 처음에 FIN ACK가 같이 응답해왔고, 또한 ACK와 FIN을 보내는 고정이 하나로 합쳐졌다.

1. 서버(223.130.200.104) > 클라이언트(10.0.2.15) : FIN ACK
2. 클라이언트(10.0.2.15) > 서버(223.130.200.104) : FIN ACK
3. 서버(223.130.200.104) > 클라이언트(10.0.2.15) : ACK

---

## 2.4 TCP의 전송 제어 기법

TCP(Transmission Control Protocol)는 뜻풀이 그대로 원할한 통신을 위해 **전송 흐름을 제어하는 기능**이다. 프로토콜 자체에 포함하고 있다. 만약 TCP가 없었더라면 개발자가 일일히 데이터를 어떤 단위로 보낼 것인지 정의해야하고, 패킷이 유실되면 어떤 예외처리를 해야하는 지까지 신경써야하기 때문에, 덕부넹 우리는 온전한 상위의 동작에만 집중할 수 있는 것이다.

보통 TCP의 전송 제어 방법은 다음 3가지로 정리된다. 

	- TMI
    TCP 제어 알고리즘은 굉장히 양도 많고 난이도도 높기 때문에 
    시간이 있을 때 파보아야할 필요성을 느꼈다. 
    지금은 개념 잡는 단계이기 때문에 이러한 예외적인 상황에 대해서 잘 알아서
    대처한다는 정도로 알고 넘어가는 것이 좋을 것같다.

---

### 2.4.1 흐름 제어(Flow Control)

- 수신자가 처리할 수 있는 데이터 속도가 다르기 때문에, 송신 측은 수신 측의 데이터 처리 속도를 파악하고 얼마나 빠르게 어느 정도의 데이터를 전송할 지 제어

- 슬라이딩 윈도우(Sliding Window) 방식을 사용
	- Window 라는 데이터를 담는 공간을 동적으로 조절하여 데이터량을 조절

![](https://velog.velcdn.com/images/atoonatoo/post/1fabe14b-8807-4b7e-a534-c20a68bdbd24/image.png)
    
---

### 2.4.2 오류 제어 (Error Control)

- 통신 도중에 데아터가 유실되거나 잘못된 데이터가 수신되었을 경우 대처 
- Go Bank N 기법과 Selective Reapeat(선택적인 재전송) 기법을 사용
	- Go Bank N 기법 : 어느 데이터로부터 오류가 발생했는지 파악하여, 그 부분만 다시 순서대로 보내 제어한다.
    - Selective Repeat 기법 : 에러난 데이터만 재전송하고 그 전에 받았던 순서가 잘못된 데이터 버퍼를 재정렬하여 제어한다.
    
    ![](https://velog.velcdn.com/images/atoonatoo/post/efc434ac-5b13-4049-9ff3-7ee9657597e1/image.png)


---

### 2.4.3 혼잡 제어 (Congestion Control)

- 네트워크가 불안정하여 데이터가 원활히 통신이 안되면 제어를 통해 재전송을 하게 되는데, 재전송 작업이 반복되면 네트워크가 붕괴될 수도 있다. 따라서 네트워크 혼잡 상태가 감지되면 송식 측의 전송 데이터 크기를 조절하여 전송량을 조절한다.

- TCP에는 Tahoe, Reno, New Reno, Cubic, Elastic-TCP 등 다양한 혼잡 제어 기법이 존재한다.

![](https://velog.velcdn.com/images/atoonatoo/post/facff987-88eb-470d-a0bc-ac3405f23697/image.png)

---

# 3. UDP 사용자 데이터그램 프로토콜

보통 UDP 와 TCP를 비교하는데 있어 아래와 같은 표를 많이 이용해왔을 것이다.

표를 보면 대략 `TCP는 신뢰성이 높고 속도가 느리다.` 와 `UDP 속도가 빠르고 신뢰성이 낮다.` 정도로 정리가 된다.

![[Pasted image 20250401210120.png]]

아무래도 클라이언트와 서버가 서로 신뢰성있는 통신을 할 수 있도록 TCP는 핸드쉐이크 과정을 거치게 되는데, 위에서 살펴본 것 처럼 데이터 하나를 전송하기 위해서도 밑작업들이 많았었다.

그렇지만 인터넷 기술이 발전하면서 전송해야하는 데이터도 단순 텍스트를 넘어서 동영상이나 음악과 같은 멀티미디어도 전송하면서 데이터의 크기가 점점 커져가며 동시에 빠른 통신이 필요해 졌다. 그래서 `HTTP 2.0` 에서는 한번 연결된 TCP 회선을 길게 유지하고 데이터도 스트림이라는 특수한 형태로 보내는 식으로 극복했지만, TCP 자체가 가지는 근본적인 특징 때문에 결과적으로 속도 한계가 있었다. (즉, 너무 헤비해서 더 이상 속도를 뽑아 낼 수가 없다.)

반면, **UDP(User Datagram Protocol)** 는 단어에서도 알 수 있듯이 **데이터그램 방식**을 사용하는 프로토콜이기 때문에 애초에 각각의 패킷 간의 순서가 존재하지 않는 독립적인 패킷을 사용한다. 

데이터그램 방식은 패킷의 목지만 정해져있다면 중간 경로는 어딜 타든 신경쓰지 않기 때문에 핸드쉐이크 과정 같은 연결 설정이 필요 없게 된다. 즉, UDP는 신뢰성을 확보하기 위해 거치던 **TCP의 과정을 거치지 않기 때문에 속도가 더 빠를 수 밖에 없다.** 그래서 UDP는 실시간 영상 스트리밍과 같은 고용량 데이터를 다루는 곳에 이용된다.

---

## 3.1 UDP 통신 과정 시각적으로 보기

UDP가 왜 TCP보다 더 빠른지는 리눅스 명령어를 통해서도 한눈에 이해할 수 있다.
기존 `netcat` 명령어에 `-u` 옵션을 주게 되면 UDP로 데이터를 송신 하게 되는데, 수신 측 로그를 보면 진짜 딸랑 한줄이 끝이다. 잘받았다는 응답 패킷 없이 무지성으로 보내기만 하는 것이다.

![[Pasted image 20250401211052.png]]

```bash
	# "Hello World" 라는 데이터를 -u 옵션(UDP로) naver.com 에 80번 포트로 전송
$ echo "Hello World" | nc -u naver.com 80
```

![[Pasted image 20250401211133.png]]

---

## 3.2 TCP 헤더와 UDP 헤더 크기 차이

TCP가 신뢰성있는 연결과 혼잡 제어 등을 위해 얼마나 많은 기능을 가지고 있는 지는 TCP와 UDP의 헤더를 비교 해보면 대각이 나온다.

### 3.2.1 TCP 헤더 구성

![[Pasted image 20250401211315.png]]

TCP의 경우 워낙 오래 전에 설계기도 했고, 이런 저런 기능이 워낙 많이 포함된 프로토콜이라 이미 헤더가 거의 풀방이다.

1. Source Port
	데이터를 생성한 애플리케이션에서 사용하는 포트 번호
2. Destination Port
	목적지 애플리케이션이 사용하는 포트 번호
3. Sequence Number Field
	세그먼트 순서를 맞추기 위한 필드
4. Acknowledgement Number Field
	다음 세그먼트 수신 준비 및 모든 데이터 수신 확인 역할
5. Data Offset Field
	TCP 헤더의 크기(5~15 : 5*32<160bit> ~ 15*32<480bit>)
6. Reserved Field
	차후의 사용을 위한 예약된 필드
7. Control Flags (SYN, ACK, FIN ... 등)
	긴급, 혼잡, 확인, 수신 거부 등의 기능
8. Window size Field
	수신자가 한번에 받을 수 있는 데이터의 양. 송신자는 Window size 만큼 ACK를 기다리지 않고 데이터를 전송. ACK가 계속 왔다갔다 하지 않아도 된다.
9. Checksum
	세그먼트 내용의 유효성과 손상 여부 검사

### 3.2.2 UDP 헤더 구성

![[Pasted image 20250401211840.png]]

반면 UDP는 데이터 전송 자체에만 초점을 맞추고 설계되었기 때문에 헤더에 들어있는게 없다. (그래서 하얀 도화지 같다는 비유가 생겼다.)

UDP의 헤더에는 출발지와 도착지, 패킷의 길이, 체크섬 밖에 없다.

1. Source Port
	데이터를 생성한 애플리케이션에서 사용하는 포트 번호
2. Destinagtion Port
	목적지 애플리케이션이 사용하는 포트 번호
3. Checksum
	중복 검사의 한 형태로, 오류 정정을 통해 공간(전자 통신)이나 시간(기억 장치) 속에서 송신된 자료의 무결성을 보호하는 단순한 방법. (TCP의 체크섬과는 다르게 UDP의 체크섬은 사용해도 되고 안해도 되는 옵션)


---

# 4. HTTP 3.0

대부분 TCP UDP를 학습할 때는 아무래도 TCP는 인터넷 통신에서 필수적으로 쓰이는 프로토콜이라 자세히 배우고, UDP는 빠르다 정도로 간단히 배우고 넘어간다만 이제는 UDP도 자세하게 공부할 필요가 생겼다. HTTP/3 는 TCP가 아닌 UDP를 채택했기 때문이다. 

2022년 11월 15일 한국 최초로 네이버도 HTTP/3을 도입하였다.

![[Pasted image 20250401212547.png]]

---

## 4.1 TCP는 구조상 한계로 개선해도 여전히 느리다.


---

# 참고 문헌

1. [참고 블로그](https://mangkyu.tistory.com/15)
2. [참고 블로그](https://inpa.tistory.com/entry/NW-%F0%9F%8C%90-%EC%95%84%EC%A7%81%EB%8F%84-%EB%AA%A8%ED%98%B8%ED%95%9C-TCP-UDP-%EA%B0%9C%EB%85%90-%E2%9D%93-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90#http_/_ip_/_tcp_/_udp_%EB%8A%94_%EB%AA%A8%EB%91%90_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)
3. [참고 유튜브](https://www.youtube.com/watch?v=ikDVGYp5dhg&t=130s)
4. [참고 기사](https://n.news.naver.com/mnews/article/022/0003754517?sid=101)


