---
interview: https://github.com/ksundong/backend-interview-question
gemini: https://gemini.google.com/u/3/app/ae1197ef7380eb06
---

---

---
### 메모장

### CS로 옮겨질 내용들

- https://www.google.com/ 을 접속할 때 일어나는 일
    - DNS Lookup
        - 브라우저가 URL을 파싱하고 **DNS 룩업**을 통해 목적지 IP를 찾아낸 후, **TCP/TLS 핸드셰이크**로 보안 연결을 설정하여 **HTTP 요청 메시지**를 패킷 단위로 서버와 주고받으며 최종적으로 화면을 렌더링하는 일련의 과정입니다.


- HTTP Request Message
    - 정해진 양식을 사용하여 어떤 서버를 만나더라도 즉시 요청을 분석하고 처리할 수 있도록 하기 위해 만들어졌다.
- 메시지 구조
    - 시작줄
        - 요청의 행동의 목적, 버전 정보, 경로 등을 간략하게 요약된 정보
    - 헤더
        - 서버가 요청을 처리하는데 필요한 부과적인 정보
    - 바디
        - 클라이언트와 서버의 통신과정에서 요청 또는 응답에 대한 데이터를 담겨져있는 정보
- DNS Lookup
    - 브라우저가 URL을 파싱한 후 실제 데이터를 주고 받기위해 숫자로된 주소를 찾는 과정
    - 이름을 숫자 주소로 바꾸는 작업
- DNS
    - IP 주소처럼 기억하기 어려운 숫자를 글자로 바꾸어 기억하기 쉽게 이용할 수 있도록 숫자 주소에 이름을 부여하기 위하는 방식
    - 예 : 전화번호부
- 

---
### CS 
#### 1. 네트워크 통신 기초

**데이터그램(Datagram)**

- **독립적인 봉투**: 수신 측과 사전 연결 없이, 목적지 주소 등 전송에 필요한 모든 정보를 스스로 담고 있는 독립적인 데이터 단위입니다.
    
- **비연결성**: 데이터를 보내기 전에 핸드셰이크를 거치지 않고 일단 목적지를 향해 던지는 방식입니다.
    
- **비신뢰성**: 데이터가 순서대로 도착하는지, 중간에 유실되었는지 확인하지 않지만 전송 속도가 매우 빠릅니다.
    

**Best-effort delivery**

- **책임 회피형 전달**: 네트워크가 데이터를 목적지까지 전달하기 위해 최선을 다하지만, 도착 여부나 데이터의 상태를 보장하지 않는 방식입니다.
    
- **단순한 메커니즘**: 복잡한 에러 복구나 재전송 로직이 없어 구조가 단순하며, 네트워크 장비 부하를 최소화합니다.
    
- **상위 계층의 몫**: 전송 중에 데이터가 사라지거나 순서가 뒤바뀌어도 네트워크는 상관하지 않으며, 상위 계층에서 별도의 로직을 처리해야 합니다.
    

**QUIC**

- **개요**: UDP를 기반으로 동작하면서, 그 위에 TCP의 신뢰성 전송 기능과 TLS의 보안 기능을 직접 구현한 계층 결합형 프로토콜입니다.
    
- **특징**: HTTP/3의 근간이 되는 기술로 사용되며 연결 설정 속도가 매우 빠릅니다.
    

#### 2. 네트워크 제어 메커니즘

**흐름 제어(Flow Control)**

- **정의**: 송신자가 수신자의 처리 속도를 넘어서지 않게 조절하여 수신 측의 버퍼가 넘치는 것을 방지하는 기술입니다.
    
- **Stop-and-Wait**: 패킷 하나를 보내고 확인 응답을 받을 때까지 기다린 후 다음 패킷을 보내는 방식입니다.
    
- **Sliding Window**: 수신 측이 한 번에 받을 수 있는 데이터 양을 알려주면, 송신 측은 응답 없이도 그만큼 연속해서 보낼 수 있는 방식입니다.
    

**혼잡 제어(Congestion Control)**

- **정의**: 네트워크 망의 데이터 처리 능력을 넘어서지 않게 조절하여 라우터 등에 패킷이 몰려 유실되는 것을 방지하는 기술입니다.
    
- **Slow Start**: 전송 속도를 아주 조금씩 늘려가며 네트워크 상태를 확인하는 기법입니다.
    
- **Congestion Avoidance**: 혼잡이 예상되는 지점부터 속도를 선형적으로 완만하게 올리는 기법입니다.
    
- **Fast Retransmit / Fast Recovery**: 패킷 손실이 감지되면 즉시 전송 속도를 줄이고 빠르게 복구하는 기법입니다.
    

**오류 제어(Error Control)**

- **정의**: 데이터가 깨지거나 유실되었을 때 이를 탐지하고 복구하여 데이터의 무결성을 보장하는 기술입니다.
    
- **Checksum**: 데이터 전송 전후의 합계를 비교하여 데이터 손상 여부를 확인하는 기법입니다.
    
- **ARQ(Automatic Repeat Request)**: 오류가 발생했거나 패킷이 유실되었을 때 재전송을 요청하는 메커니즘입니다.
    

#### 3. 개발 및 웹 개념

**파싱(Parsing)**

- **정의**: 일련의 문자열을 분석하여 컴퓨터가 이해하고 처리하기 쉬운 구조적 데이터로 변환하는 과정입니다.
    
- **파서(Parser)**: 파싱 작업을 수행하는 프로그램이며, 컴파일러나 인터프리터의 핵심 구성 요소입니다.
    

**멱등성(Idempotency)**

- **정의**: 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미합니다.
    

**CORS(Cross-Origin Resource Sharing)**

- **정의**: 한 출처에서 실행 중인 웹 앱이 다른 출처의 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제입니다.
    
- **프리플라이트(Preflight)**: 실제 요청 전 브라우저가 OPTIONS 메서드를 보내 서버가 해당 요청을 허용하는지 확인하는 과정입니다.
    

#### 4. 서비스 및 소프트웨어 구조

**SaaS(Software as a Service)**

- **웹 기반 접근성**: 별도의 설치 과정 없이 웹 브라우저만 있으면 언제든 접속하여 소프트웨어를 사용할 수 있습니다.
    
- **구독 모델**: 매달 또는 매년 사용료를 지불하는 방식으로 초기 도입 비용 부담이 적습니다.
    
- **자동 업데이트**: 공급업체가 서버에서 업데이트를 진행하여 모든 사용자가 즉시 최신 버전을 사용하게 됩니다.
    
- **멀티 테넌시**: 하나의 소프트웨어를 수많은 사용자가 공유하되 각 데이터는 철저히 분리되어 보호받습니다.
    

**애플리케이션(Application)**

- **데스크톱 앱**: PC나 노트북 운영체제에 설치하여 사용하는 소프트웨어입니다.
    
- **모바일 앱**: 스마트폰이나 태블릿 전용 운영체제에서 작동하도록 제작된 소프트웨어입니다.
    
- **웹 앱**: 설치 없이 웹 브라우저를 통해 실행되며 접근성이 뛰어난 소프트웨어입니다.
    

**컴퓨팅(Computing)**

- **정의**: 컴퓨터 기술을 사용하여 데이터 처리, 문제 해결, 정보 생성 등 모든 활동을 수행하는 것을 의미합니다.
    
- **3대 핵심 요소**: 데이터의 입력, 처리, 그리고 결과의 출력이 핵심을 이룹니다.
    

#### 5. 최신 트렌드

**바이브 코딩(Vibe Coding)**

- **정의**: 엄밀한 설계보다는 직관에 의존하거나, AI에게 구체적인 구현을 맡기고 개발자는 방향성만 설정하는 코딩 방식입니다.

### Interview

#### 1. 네트워크 (Network)

**웹 통신의 흐름 (HTTPS 접속 시)**

- **주소 파싱 및 요청 생성**: 브라우저가 URL을 파싱하여 HTTP Request 메시지를 만들고 OS에 전송을 요청합니다.
    
- **DNS Lookup**: 도메인을 IP로 변환하기 위해 브라우저 캐시, hosts 파일, DNS 서버 순으로 확인합니다.
    
- **프로토콜 스택 및 패킷 송출**: OS 내장 네트워크 소프트웨어가 패킷에 제어 정보를 붙여 LAN 어댑터를 통해 전기 신호로 송출합니다.
    
- **경로 제어 및 전달**: 스위칭 허브, 라우터, ISP를 거쳐 인터넷 핵심부로 전달되며 최적의 경로로 목적지 LAN에 도착합니다.
    
- **서버 수신 및 응답**: 방화벽 검사와 캐시 서버 확인 후 웹 서버 애플리케이션에 전달되며, 역순으로 응답이 회송됩니다.
    

**TCP vs UDP**

- **TCP (Transmission Control Protocol)**: 연결 지향형으로 가상 회선을 수립하여 흐름 제어, 혼잡 제어 등을 통해 신뢰성을 보장하지만 상대적으로 느립니다.
    
- **UDP (User Datagram Protocol)**: 비연결형으로 데이터를 데이터그램 단위로 전송하며 신뢰성 확인 절차가 없어 스트리밍 등 연속성이 중요한 서비스에 유리합니다.
    
- **HTTP/3와 QUIC**: UDP를 기반으로 신뢰성을 직접 구현하여 연결 설정 속도를 획기적으로 개선한 최신 프로토콜입니다.
    

**TCP 핸드셰이크 (Handshake)**

- **3-way (연결)**: SYN(n) -> SYN(m)+ACK(n+1) -> ACK(m+1) 과정을 통해 클라이언트와 서버 간 데이터 전송 가능 여부를 확인합니다.
    
- **4-way (해제)**: 연결 해제를 통지하고 양측의 정리가 끝난 후 해제하며, 유실된 패킷 수신을 위해 클라이언트가 잠시 대기(TIME_WAIT)합니다.
    

**HTTP & HTTPS**

- **보안성**: HTTP는 평문 전송으로 탈취가 용이하나, HTTPS는 SSL/TLS 계층을 추가하여 데이터를 암호화합니다.
    
- **SSL 핸드셰이크**: 제어 토큰 교환 후 인증서 검증을 거쳐 서버의 공개키로 통신용 대칭키를 암호화하여 공유하는 과정입니다.
    

**HTTP 메서드 및 REST**

- **GET vs POST**: GET은 정보 조회를 위한 요청으로 캐싱이 가능하며, POST는 서버 상태를 변경하는 생성 요청으로 멱등성이 보장되지 않습니다.
    
- **주요 메서드**: PUT(전체 수정/생성), PATCH(부분 수정), DELETE(삭제) 등이 있으며 자원의 상태를 명확히 표현합니다.
    
- **RESTful**: URI로 자원을 표시하고 메서드로 행위를 정의하여 사람이 읽기 쉽고 표준화된 API 설계를 지향하는 방식입니다.
    

#### 2. 운영체제 (Operating System)

**프로세스와 스레드**

- **자원 공유**: 프로세스는 독립된 메모리를 할당받지만, 스레드는 프로세스 내 자원(Code, Data, Heap)을 공유하여 통신 효율이 높습니다.
    
- **컨텍스트 스위칭**: 실행 중인 작업을 PCB에 저장하고 새 작업의 상태를 레지스터에 로드하는 과정이며, 스레드 간 전환이 훨씬 빠릅니다.
    

**동기 및 비동기 (Sync/Async & Blocking/Non-blocking)**

- **동기/비동기**: 작업의 완료 시점과 다음 작업의 시작 시점을 맞추는지 여부로 구분하며 비동기는 처리 효율이 높지만 복잡합니다.
    
- **블로킹/논블로킹**: 제어권을 누가 가지느냐의 차이로, 논블로킹은 작업 완료 여부와 상관없이 제어권을 즉시 반환받습니다.
    

**멀티스레드와 동기화**

- **Thread-safe**: 여러 스레드가 동시에 접근해도 데이터 정합성이 유지되는 상태이며, 불변 객체 사용이나 동기화 블록 등으로 구현합니다.
    
- **교착상태 (Deadlock)**: 서로 자원을 점유한 채 상대의 자원 반납을 기다리는 상태로 상호배제, 점유대기, 비선점, 순환대기 조건이 충족될 때 발생합니다.
    
- **세마포어 vs 뮤텍스**: 세마포어는 여러 프로세스가 접근 가능한 공유 자원 관리 방식이며, 뮤텍스는 한 번에 하나만 접근하도록 락을 거는 방식입니다.
    

#### 3. 데이터베이스 (Database)

**인덱스 (Index)**

- **사용 이유**: 데이터 검색 성능을 비약적으로 향상시키기 위해 사용하지만, 추가 저장 공간과 쓰기 성능 저하라는 비용이 발생합니다.
    
- **유의 사항**: 카디널리티가 높고 선택도가 좋은 컬럼에 인덱스를 생성해야 하며 불필요한 인덱스는 시스템 리소스를 낭비합니다.
    

**트랜잭션과 ACID**

- **트랜잭션**: 데이터베이스의 상태를 변화시키는 논리적인 작업 단위로 전부 성공하거나 전부 실패해야 합니다.
    
- **ACID 원칙**: 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 지속성(Durability)을 통해 데이터 안전성을 보장합니다.
    
- **격리 수준**: READ UNCOMMITTED부터 SERIALIZABLE까지 존재하며, 고립도가 높을수록 데이터 정합성은 좋아지지만 성능은 떨어집니다.
    

**NoSQL 및 특수 DB**

- **RDBMS vs NoSQL**: RDBMS는 정형화된 구조와 관계를 중시하며, NoSQL은 유연한 확장성과 다양한 형태(Key-Value, Document 등)를 지원합니다.
    
- **Redis**: 인메모리 기반 Key-Value 저장소로 싱글 스레드로 동작하며 세션 관리나 캐싱에 주로 사용됩니다.
    
- **Elastic Search**: 역색인 구조를 사용하는 검색 엔진으로 전문 검색에서 뛰어난 성능을 보이며 ELK 스택과 함께 분석 용도로 쓰입니다.
    

#### 4. 언어 및 프레임워크 (Java/Spring/Python)

**JVM 및 Java 특징**

- **JVM 구조**: 클래스 로더, 실행 엔진, 런타임 데이터 영역으로 구성되어 플랫폼 독립적인 실행 환경을 제공합니다.
    
- **Garbage Collection (GC)**: 힙 영역에서 사용되지 않는 객체를 자동 제거하며, 수행 시 시스템이 멈추는 Stop-the-world가 발생합니다.
    
- **오버라이딩 vs 오버로딩**: 오버라이딩은 상위 클래스 메서드 재정의(런타임 다형성), 오버로딩은 이름은 같지만 매개변수가 다른 메서드 정의(컴파일 타임 다형성)입니다.
    

**Spring Framework**

- **DI/IoC**: 제어의 역전을 통해 객체 생성을 프레임워크가 담당하며, 의존성 주입을 통해 결합도를 낮추고 유연성을 확보합니다.
    
- **Bean 생명주기**: 객체 생성, 의존 설정, 초기화, 사용, 소멸 순으로 관리되며 기본적으로 싱글톤 스코프로 운영됩니다.
    
- **DispatcherServlet**: 프론트 컨트롤러 패턴을 사용하여 모든 요청을 중앙에서 받아 적절한 핸들러로 위임합니다.
    

**JPA (Java Persistence API)**

- **영속성 컨텍스트**: 엔티티를 영구 저장하는 환경으로 1차 캐시, 동일성 보장, 쓰기 지연, 변경 감지 등의 이점을 제공합니다.
    
- **N + 1 문제**: 연관 엔티티 조회 시 의도치 않은 추가 쿼리가 발생하는 현상으로 Fetch Join이나 Batch Size 조절로 해결합니다.
    

#### 5. 기타 및 인프라 (Architecture & Infrastructure)

**디자인 패턴**

- **싱글톤 패턴**: 객체의 인스턴스를 단 하나만 생성하여 공유하는 패턴이지만 테스트가 어렵고 상태 관리에 주의해야 합니다.
    
- **전략 패턴**: 알고리즘을 캡슐화하여 교체 가능하게 만드는 패턴으로 OCP 원칙을 잘 따르는 구조입니다.
    

**배포 전략 (CI/CD)**

- **CI/CD**: 지속적 통합과 배포를 통해 코드 변경 사항을 자동 테스트하고 운영 환경에 반영하여 개발 효율을 극대화합니다.
    
- **무정지 배포**: 롤링(순차 교체), 카나리(일부 유저 우선 적용), 블루/그린(세트 교체) 방식을 통해 서비스 중단 없는 업데이트를 수행합니다.
    

**최신 트렌드 (gRPC & K8s)**

- **gRPC**: Protobuf를 사용하여 HTTP/2 기반으로 통신하며 JSON 대비 월등한 속도와 효율을 보여 MSA 구조에서 선호됩니다.
    
- **Kubernetes**: 컨테이너화된 애플리케이션의 배포, 스케일링, 운영을 자동화하는 오케스트레이션 플랫폼입니다.

### Programming Know-how

**효율적인 AI 협업**

- **명세 기반 코딩**: 바이브 코딩을 할 때는 미리 명세 문서를 작성하고 그 명세를 기반으로 코딩하는 것이 정확도를 높이는 권장 방법입니다.
    
- **멀티 AI 활용**: AI 사이트를 하나만 사용하는 것이 아니라 각 용도와 강점에 맞게 여러 도구를 병행하여 사용하는 것이 매우 효율적입니다.


### Project technology Stack

#### 1. 부하 테스트 설계와 도구 선정

##### k6

- 목적: 코드로 작성하고 CLI에서 실행하는 개발자 친화적 테스트 도구
    
- 동작 원리: JavaScript 테스트 스크립트를 k6 런타임이 해석하여 가상 사용자(VU)를 Go루틴으로 생성하고 HTTP 요청을 병렬 실행하며 메트릭을 수집합니다.
    
- 장점: Go 기반의 경량 VU 모델로 동일 자원 대비 높은 동시성을 확보하며, CLI 중심 설계로 CI/CD 파이프라인 연동이 쉽습니다. 코드 기반이라 테스트 조건의 재현성이 뛰어납니다.
    
- 단점: GUI가 없어 비개발자의 진입 장벽이 있으며, 복잡한 시나리오를 시각적으로 설계하기 어렵고 기본적으로 HTTP 중심이라 특수 프로토콜은 확장이 필요합니다.
    
- 한 문장 기억 공식: k6는 GUI 대신 JavaScript와 Go를 선택해 빠르고 자동화에 강하지만 개발자 중심으로 설계된 도구입니다.
    
- 장단점 연결: 왜 빠른가? (Go + goroutine) / 왜 자동화에 강한가? (CLI + 코드) / 왜 불편한가? (GUI 없음)
    

##### JMeter

- 목적: GUI를 통해 복잡한 부하 테스트 시나리오를 설계하고 실행하는 범용 도구
    
- 동작 원리: GUI에서 구성된 Test Plan에 따라 Thread Group이 가상 사용자를 생성하고, Sampler가 요청을 실행하면 Listener가 결과를 수집하여 시각화합니다.
    
- 장점: 조건 분기나 반복 등 복잡한 시나리오를 시각적으로 조립할 수 있고, HTTP 외에도 JDBC, FTP 등 지원 프로토콜 범위가 매우 넓어 비개발자도 접근 가능합니다.
    
- 단점: Java Thread 모델 특성상 고부하 시 자원 소모가 크며, GUI 실행 자체가 결과에 성능 왜곡을 줄 수 있습니다. 설정 파일 관리 측면에서 자동화와 버전 관리가 까다롭습니다.
    
- 한 문장 기억 공식: JMeter는 GUI와 Java Thread를 선택해 복잡한 시나리오에 강하지만 대규모 부하와 자동화에는 불리합니다.
    
- 장단점 연결: 왜 시나리오에 강한가? (GUI + 컨트롤러 구조) / 왜 무거운가? (Java Thread 기반) / 왜 CLI 실행을 권장하나? (GUI 성능 간섭 제거)
    

##### nGrinder

- 목적: 웹 UI를 통해 분산 부하 테스트를 쉽게 운영하기 위한 엔터프라이즈용 도구
    
- 동작 원리: 중앙 Controller가 웹 UI로 시나리오를 관리하고, 실행 시 여러 Agent에 작업을 분배합니다. Agent 내 엔진이 스크립트를 실행하면 결과를 다시 통합합니다.
    
- 장점: Agent 수평 확장을 통한 대규모 분산 테스트에 유리하며, 모니터링과 결과 확인을 한 화면에서 처리할 수 있어 조직 단위 운영에 적합한 관리 기능을 제공합니다.
    
- 단점: Controller와 Agent 등 인프라 구성 복잡도가 높고, Jython이나 Groovy 기반 스크립트 작성이 필요하여 Java 계열 이해가 요구됩니다. 경량 테스트에는 오버엔지니어링일 수 있습니다.
    
- 한 문장 기억 공식: nGrinder는 중앙 관리와 분산 구조를 선택해 대규모 부하에 강하지만 설정과 운영이 무겁습니다.
    
- 장단점 연결: 왜 대규모에 강한가? (분산 Agent) / 왜 운영이 편한가? (웹 UI + 중앙 관리) / 왜 복잡한가? (인프라 필요성)
    

##### Locust

- 목적: Python 코드로 사용자 행동을 자연스럽게 표현하는 분산 부하 테스트 도구
    
- 동작 원리: Python으로 사용자 행동을 정의하면 Master 노드가 제어하고 여러 Worker 노드가 가상 사용자를 실행하여 결과를 실시간 집계합니다.
    
- 장점: Python 코드로 복잡한 조건이나 상태를 자유롭게 표현할 수 있고, Worker 확장이 쉬우며 웹 UI를 통해 실시간으로 응답 시간과 실패율을 확인할 수 있습니다.
    
- 단점: Python 런타임의 한계로 k6 대비 성능 효율이 낮아 고부하 시 CPU 사용량이 높습니다. 웹 UI 중심이라 완전한 자동화에는 추가 작업이 필요합니다.
    
- 한 문장 기억 공식: Locust는 Python의 표현력을 선택하는 대신 극단적인 성능 효율은 양보한 도구입니다.
    
- 장단점 연결: 왜 시나리오가 자연스러운가? (Python 기반) / 왜 분산이 쉬운가? (Master-Worker) / 왜 성능이 상대적으로 약한가? (Python 런타임)
    

#### 2. 트래픽 부하 분산을 위한 로드 밸런서 구축

##### Nginx

- 목적: 이벤트 기반 비동기 구조를 통해 대규모 동시 접속 문제를 해결하는 웹 서버 및 프록시
    
- 동작 원리: Master 프로세스가 설정을 로드하고 Worker를 관리하며, 각 Worker는 이벤트 루프를 통해 수천 개의 연결을 단일 스레드에서 비동기로 처리합니다.
    
- 장점: 메모리 사용량이 매우 적고 동시 처리 성능이 탁월하며, 특히 정적 파일 서비스와 리버스 프록시 역할에서 높은 안정성을 보입니다.
    
- 단점: 애플리케이션 로직을 직접 처리할 수 없어 외부 WAS 연동이 필수적이며, 설정 파일 구조가 복잡해질 수 있고 CPU 코어 수에 따른 Worker 설정이 중요합니다.
    
- 한 문장 기억 공식: Nginx는 스레드 대신 이벤트 기반 모델을 선택해 동시성에 강하지만 로직 처리 서버는 아닙니다.
    

##### HAProxy

- 목적: 고가용성과 초고성능 트래픽 분산에 특화된 전문 로드 밸런서
    
- 동작 원리: Frontend에서 연결을 수신하고 설정된 알고리즘에 따라 Backend 서버 풀로 분산하며, 지속적인 Health Check를 통해 정상 서버로만 트래픽을 전달합니다.
    
- 장점: 네트워크 레벨 최적화로 처리량이 매우 높고 지연 시간이 짧습니다. ACL이나 가중치 조절 등 매우 정교한 트래픽 제어와 세션 유지 기능을 제공합니다.
    
- 단점: 웹 서버 기능이 없어 정적 파일을 직접 제공할 수 없고, 설정 난이도가 높은 편이며 시각화보다는 로그와 메트릭 데이터 중심의 운영을 요구합니다.
    
- 한 문장 기억 공식: HAProxy는 웹 서버 기능을 포기한 대신 트래픽 분산과 고가용성 자체에 올인한 전문 도구입니다.
    

##### AWS ALB (Application Load Balancer)

- 목적: L7 계층에서 지능적으로 트래픽을 분산하는 클라우드 관리형 로드 밸런서
    
- 동작 원리: Listener가 요청을 수신하면 호스트, 경로, 헤더 등의 규칙을 평가하여 적절한 대상 그룹(Target Group) 내 리소스로 트래픽을 전달합니다.
    
- 장점: URL이나 호스트 기반 라우팅이 가능해 마이크로서비스에 최적화되어 있으며, AWS가 설치와 확장을 직접 관리하므로 운영 부담이 거의 없습니다.
    
- 단점: L4 레벨의 제어가 불가능하고 AWS 외부 환경에서는 사용할 수 없는 벤더 종속성이 있습니다. HAProxy 수준의 세밀한 커스터마이징은 어렵습니다.
    
- 한 문장 기억 공식: ALB는 운영 책임을 AWS에 넘기는 대신 L7 라우팅 자동화에 집중한 관리형 서비스입니다.
    

##### Traefik

- 목적: 서비스 디스커버리와 연동하여 설정 없이 자동 라우팅을 수행하는 클라우드 네이티브 프록시
    
- 동작 원리: Docker나 Kubernetes 같은 프로바이더로부터 서비스 변화를 실시간 감지하고, 컨테이너 라벨이나 주석을 읽어 라우팅 규칙을 자동으로 생성합니다.
    
- 장점: 서비스 추가 시 수동 설정이 필요 없고 컨테이너 환경과 매우 친숙하며, 재시작 없이 설정을 실시간으로 반영할 수 있어 동적인 환경에 적합합니다.
    
- 단점: 정적인 전통 서버 환경에서는 이점이 적고 고수준 추상화로 인해 세밀한 저수준 제어나 복잡한 장애 디버깅이 어려울 수 있습니다.
    
- 한 문장 기억 공식: Traefik은 수동 설정 대신 자동 탐색을 선택해 클라우드 환경의 편의성을 극대화한 프록시입니다.
    

#### 3. 중앙 집중형 로그 수집 및 시각화

##### 3.1 로그 저장소

- Elasticsearch: 역색인 구조를 통해 대규모 텍스트 검색과 실시간 분석에 특화된 분산 엔진입니다. 검색 성능이 탁월하지만 강한 트랜잭션을 지원하지 않으며 운영 난이도가 높습니다.
    
- OpenSearch: Elasticsearch의 오픈소스 대안으로, 라이선스 제약 없이 모든 기능을 사용할 수 있습니다. 높은 호환성을 유지하며 커뮤니티 중심으로 발전 중입니다.
    
- Grafana Loki: 로그 본문을 색인하지 않고 라벨만 인덱싱하여 저장 비용을 획기적으로 낮춘 시스템입니다. 검색 자유도는 낮지만 메트릭과 통합 분석하기 좋습니다.
    
- Graylog: 검색 엔진 위에 로그 파이프라인 처리와 보안 기능을 얹은 관리 플랫폼입니다. 강력한 파싱 기능을 제공하며 GUI 기반 운영이 편리합니다.
    

##### 3.2 로그 수집기

- Filebeat: 서버 부담이 거의 없는 경량 에이전트로, 로그 파일의 위치를 추적하며 안정적으로 전송하는 데 집중합니다. 복잡한 처리 기능은 부족합니다.
    
- Fluent Bit: C로 작성되어 메모리 효율이 극도로 높으며 컨테이너 환경의 로그를 수집하고 필터링하는 데 최적화되어 있습니다.
    
- Vector: Rust 기반의 고성능 도구로 로그 수집, 변환, 전송을 통합 처리합니다. 안정성이 높고 다양한 데이터 소스와 목적지를 지원합니다.
    
- rsyslog: 유닉스/리눅스 시스템의 표준 로그 처리 시스템으로, 로컬 시스템 로그를 수집하고 네트워크를 통해 원격지로 전달하는 신뢰도 높은 도구입니다.
    

##### 3.3 시각화 및 모니터링

- Kibana: Elasticsearch 전용 UI로 탐색과 대시보드 구성에 최적화되어 있습니다. Elastic Stack과의 깊은 통합이 최대 장점입니다.
    
- Grafana: 다양한 데이터 소스를 지원하는 대시보드 도구로, 로그보다는 메트릭 기반의 실시간 모니터링 시각화에서 독보적인 위치를 가집니다.
    
- OpenSearch Dashboards: OpenSearch 전용 시각화 도구로 기존 Kibana의 사용성을 유지하며 오픈소스 기능을 확장 제공합니다.
    

#### 4. DB 커넥션 풀 및 캐싱 시스템

##### DB 커넥션 풀

- HikariCP: 압도적인 성능과 안정성을 제공하는 최신 Java 커넥션 풀로, 오버헤드를 최소화하도록 설계되었습니다.
    
- Apache DBCP2: 오랜 역사를 가진 안정적인 커넥션 풀로 다양한 설정 옵션을 제공하며 호환성이 좋습니다.
    
- Tomcat JDBC Pool: 톰캣 서버에 내장되어 경량화와 고성능을 목표로 설계된 커넥션 풀입니다.
    

##### 캐싱 시스템

- Redis: 메모리 기반의 키-값 저장소로 다양한 데이터 구조를 지원하며 분산 캐시와 세션 관리 등에 널리 쓰입니다.
    
- Memcached: 단순하고 빠른 캐싱만을 목적으로 하는 분산 메모리 시스템으로 멀티스레드 기반의 성능이 좋습니다.
    
- Caffeine: 로컬 메모리 캐시 라이브러리로 Java 환경에서 가장 높은 처리량과 성능을 보여줍니다.
    
- Hazelcast: 분산 데이터 그리드로 애플리케이션 간 데이터 공유와 클러스터링 기능을 제공합니다.
    

#### 5. 보안 및 아키텍처 설계

##### 인증 및 인가

- Spring Security: 스프링 기반 앱의 인증, 인가, 취약점 방어를 담당하는 포괄적 보안 프레임워크입니다.
    
- Keycloak: 오픈소스 인증 관리 서버로 OAuth2, SAML 등 표준 프로토콜을 통한 통합 인증(SSO)을 제공합니다.
    
- 상태 관리 방식: 쿠키(클라이언트 저장), 세션(서버 메모리 저장), 토큰(JWT 등 자가 수용적 인증 정보) 방식을 통해 유저 상태를 식별합니다.
    

##### 도메인 및 영속성 계층

- 도메인 모델 패턴: 로직이 도메인 객체 내에 집중되어 복잡한 비즈니스 규칙을 관리하기에 적합합니다.
    
- Spring Data JPA: 인터페이스만으로 데이터 접근 계층을 처리하며 자바 객체와 DB 테이블을 매핑합니다.
    
- QueryDSL: 타입 세이프한 쿼리 작성을 지원하여 컴파일 시점에 오류를 발견할 수 있게 도와줍니다.
    
- CQRS: 명령(C)과 조회(Q) 책임을 분리하여 각 기능의 성능과 확장성을 최적화하는 패턴입니다.
    

#### 6. AI API 연동

- OpenAI API: GPT 모델을 기반으로 한 텍스트 생성 및 분석 서비스로 가장 넓은 생태계를 보유하고 있습니다.
    
- Claude API: 긴 문맥 처리와 논리적 추론 능력이 뛰어난 Anthropic의 언어 모델 서비스입니다.
    
- Gemini API: 구글의 멀티모달 AI 서비스로 구글 생태계와의 연동성과 효율적인 성능을 제공합니다.